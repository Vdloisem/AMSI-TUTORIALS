{"title":"The Object Constraint Language (OCL): An Overview","markdown":{"yaml":{"title":"The Object Constraint Language (OCL): An Overview"},"headingText":"The Need for Precision: What UML Diagrams Don't Say","containsRefs":false,"markdown":"\n\nThis chapter introduces the **Object Constraint Language (OCL)**, a formal language used to add precise and unambiguous rules to UML models. We will explore why UML diagrams alone are often insufficient and how OCL helps to create more rigorous and verifiable software specifications.\n\n\nAs we have seen, UML diagrams, especially Class Diagrams, are powerful tools for modelling the static structure of a system. However, they cannot capture all the business rules and constraints that govern a system's behaviour. A diagram can be syntactically correct but still allow for situations that are logically incorrect or violate business rules.\n\nConsider the following class diagram for a car rental system:\n\n![A class diagram for a car rental system.](images/car-rental-cd.png){fig-alt=\"Class diagram for a car rental system.\" width=\"100%\"}\n\nThis diagram leaves many important questions unanswered:\n\n* Can a customer who is on the blacklist rent a new car?\n* How is the price of a rental calculated?\n* Can the pickup and drop-off branches be different?\n* Should a driver's license be valid for the entire rental period?\n\nWhile we could add this information in natural language, this approach is notoriously unreliable. Natural language specifications are prone to what are often called the **\"7 Deadly Sins\"**:\n\n::: {.callout-warning icon=\"false\" title=\"The 7 Deadly Sins of Natural Language Specification\"}\n* **Ambiguity:** A statement can be interpreted in multiple ways.\n* **Contradiction:** Two or more rules in the specification conflict with each other.\n* **Silence (Incompleteness):** A required rule or feature is not mentioned at all.\n* **Noise:** The text contains irrelevant information that obscures the actual requirements.\n* **Over-specification:** The text unnecessarily describes implementation details (\"how\") instead of requirements (\"what\").\n* **Vagueness:** The requirements are not stated precisely enough to be verified.\n* **Wishful Thinking:** A requirement is described that is impossible to implement.\n:::\n\nThese issues make automated verification impossible and lead to costly errors in implementation. To solve this, we need a formal, unambiguous way to express these rules, which is precisely the role of OCL.\n\n\n## Introduction to OCL\n\nTo solve the problems of ambiguity and imprecision, the **Object Constraint Language (OCL)** was created. It is the official standard from the OMG (Object Management Group) for adding formal constraints to UML models.\n\nOCL is a **declarative, textual, and formal language**. This means:\n\n* **Declarative:** You specify *what* should be true, not *how* to check it.\n* **Textual:** It integrates seamlessly with the graphical nature of UML diagrams.\n* **Formal:** It has a well-defined mathematical foundation, which removes ambiguity.\n\nIt is designed to be a middle ground: more precise than natural language, but less complex and easier to learn than purely mathematical formalisms.\n\n### Language Philosophy\n\nTo use OCL correctly, it is crucial to understand its core philosophy: OCL is a **pure specification language**, not a programming language. This has two major consequences:\n\n::: {.callout-note icon=\"true\" title=\"No Side Effects\"}\nAn OCL expression is a query that can only **read** the state of the model, it can **never change it**. You cannot use OCL to assign a value to an attribute, create an object, or call an operation that modifies the system's state. This guarantees that checking a constraint will never alter the system you are verifying.\n:::\n\n::: {.callout-note icon=\"true\" title=\"Instantaneous Evaluation\"}\nThe evaluation of an OCL expression is considered to be **instantaneous**. This is a powerful abstraction that means the state of the system is \"frozen\" during the evaluation of a constraint. You don't have to worry about other parts of the system changing while your expression is being checked, which greatly simplifies writing complex rules.\n:::\n\n## Main Applications of OCL\n\nOCL is a versatile language used to add precision to a model in several key ways. Let's explore its main applications with concrete examples based on our car rental system.\n\n1.  **Constraining Models (Invariants):**\n    The primary use of OCL is to write **invariants**. An invariant is a rule that must be true for all instances of a class at all times.\n\n    *Example: A customer's discount must always be a positive value.*\n    ```ocl\n    context Customer inv:\n      self.discount >= 0\n    ```\n    **Explanation:** This simple invariant ensures that for any `Customer` object, the `discount` attribute (which is an `Integer` in the diagram) can never be negative.\n\n2.  **Specifying Contracts (Preconditions & Postconditions):**\n    OCL is used to define formal contracts for operations. A **precondition** must be true *before* an operation is executed, and a **postcondition** must be true *after*.\n\n    *Example: To extend a rental, its state must be 'active'.*\n    ```ocl\n    context Rental::extendRental(newDate: Date)\n      pre must_be_active:\n        self.state = 'active'\n    ```\n    **Explanation:** This precondition checks that the `state` attribute of the `Rental` instance is equal to the string `'active'`. The operation cannot be called otherwise.\n\n3.  **Specifying Derived Values:**\n    OCL can define how the value of an attribute should be calculated from other information. This is for values that are not stored directly.\n\n    *Example: Let's define a derived boolean attribute `isPrivileged` for a `Customer`.*\n    ```ocl\n    context Customer derive: isPrivileged: Boolean =\n      self.premium = true and self.discount > 10\n    ```\n    **Explanation:** This rule states that a customer is considered \"privileged\" if and only if their `premium` status is true and their `discount` is greater than 10.\n\n4.  **Defining Queries:**\n    You can use OCL to navigate through the model to retrieve information, much like a query.\n\n    *Example: A query to get the set of all active rentals for a specific customer.*\n    ```ocl\n    context Customer\n      def: getActiveRentals(): Set(Rental) =\n        self.rental->select(r | r.state = 'active')\n    ```\n    **Explanation:** This defines a new operation `getActiveRentals` on the `Customer` class. It navigates to the customer's collection of `rental` and uses the `select` iterator to return a new set containing only those rentals whose `state` is 'active'.\n\n\n## Fundamental OCL Concepts\n\nTo write meaningful constraints, we first need to understand the two pillars of the OCL language: its **robust typing system**, and its **precise syntax and the formal semantics** that underpin it.\n\n\n\n### OCL is a Typed Language\n\nEvery element in OCL, from an attribute to the result of a complex navigation, has a **type**. This strong typing system ensures that expressions are well-formed and prevents errors, much like in languages like Java. OCL's type system is built from three sources:\n\n#### Primitive Types\nOCL includes four fundamental, built-in types that are the basis for most expressions:\n\n* `Integer` (e.g., `5`, `-10`)\n* `Real` (e.g., `3.14`, `-0.5`)\n* `String` (e.g., `'active'`, `'John Doe'`)\n* `Boolean` (`true`, `false`)\n\n#### UML Model Types\nThis is a powerful feature: **every classifier you define in your UML model automatically becomes a new type in OCL**. If you have a class named `Customer` in your diagram, `Customer` becomes a valid type in your OCL expressions. This allows you to write constraints that are perfectly tailored to your specific domain.\n\n#### Collection Types\nBecause navigating associations often results in multiple objects, OCL has a rich set of built-in collection types to handle them. The collection is an abstract type with four concrete subtypes:\n\n| Collection Type | Order Matters? | Duplicates Allowed? | Example Literal |\n| :--- | :--- | :--- | :--- |\n| **`Set(T)`** | No | No | `Set{1, 2, 3}` |\n| **`OrderedSet(T)`**| Yes | No | `OrderedSet{1, 2, 3}`|\n| **`Bag(T)`** | No | Yes | `Bag{1, 2, 2, 3}` |\n| **`Sequence(T)`**| Yes | Yes | `Sequence{1, 3, 2, 3}`|\n\nBy default, navigating a `*` multiplicity association returns a `Set`. Understanding these collection types is essential, as most non-trivial OCL expressions involve manipulating collections.\n\n### Special OCL Types\n\nBeyond the primitive and model-based types, OCL provides a set of special, built-in classifiers that are essential for writing advanced constraints. The hierarchy of these types is shown in the diagram below.\n\n![A class diagram showing the OCL Type Hierarchy, with Classifier at the top.](images/ocl-type-hierarchy.png){fig-alt=\"The OCL Type Hierarchy\" width=\"100%\"}\n\n\nLet's explore the most important ones:\n\n* **`OclAny`**: This is the supertype of all other types in OCL (except for collection and tuple types). Any operation defined on `OclAny` (like `oclIsTypeOf()`) is available on all objects in your model.\n\n* **`OclVoid`**: This type has only one possible value: `null`. It is used to check if a property has been set or not. Any expression that results in a division by zero, for example, will evaluate to `null`. You can check for this value using the `oclIsUndefined()` operation.\n\n* **`OclInvalid`**: This type has only one value: `invalid`. It is used to represent the result of an ill-formed expression, for instance, when trying to navigate from `null`. It is a subtype of all other types, meaning an `invalid` value can \"poison\" an entire expression. You can check for it with `oclIsInvalid()`.\n\n* **`TupleType`**: A tuple is a structured type that groups together several named parts, each with its own type. It's similar to a struct or a record and is very useful for returning multiple values from a query operation.\n\n    ```ocl\n    Tuple{name: String = 'Mikel', id: Integer = 123}\n    ```\n\n* **`OclState`**: This special type is used exclusively within state machine diagrams. The operation `oclIsInState(stateName: OclState)` allows you to write a constraint that checks if an object is currently in a specific state, which is very powerful for defining state-dependent invariants.\n\n* **`OclMessage`**: Used in interaction diagrams (like sequence diagrams), this type allows you to write constraints on the messages exchanged between objects. For example, you can check if a specific message has been sent or received.\n\n\n### Type Conformance and Subtyping\n\nThe OCL type system is not flat, it has a rich hierarchy that defines which types are considered subtypes of others. This is known as **type conformance**. Understanding these rules is crucial, as it determines when a value of one type can be used where a value of another type is expected.\n\nThe main rules of type conformance in OCL are as follows:\n\n1.  For primitive numbers, the hierarchy is logical: `UnlimitedNatural` is a subtype of `Integer`, which is a subtype of `Real`.\n2.  `OclAny` is the ultimate supertype for all non-collection types. This means any object from your UML model is conformant to `OclAny`.\n3.  The hierarchy of your **UML model types** mirrors the generalization (inheritance) relationships in your class diagram. If you have a `Student` class that inherits from `Person`, then `Student` is a subtype of `Person` in OCL.\n4.  For collections, `Set(T)`, `Bag(T)`, `Sequence(T)`, and `OrderedSet(T)` are all subtypes of the general `Collection(T)` type.\n5.  The special types have their own rules:\n    * `OclVoid` (representing `null`) is a subtype of all other types (except `OclInvalid`).\n    * `OclInvalid` is the ultimate subtype, it is a subtype of *every other type*. This explains why an `invalid` value can propagate through and \"poison\" any expression.\n\nThis hierarchy is visualized in the diagram below.\n\n![A class diagram showing the OCL Type Hierarchy and a list of the 7 conformance rules.](images/type-conformance-rules.png){fig-alt=\"The OCL Type Hierarchy and its conformance rules.\" width=\"30%\"}\n\n### Standard OCL Operators\n\nLike any language, OCL comes with a standard set of operators to perform logical, relational, and arithmetic operations. These are the building blocks for creating complex boolean expressions within your constraints.\n\n#### Logical Operators\nOCL supports the standard boolean logic operators. Note that they are written in lowercase.\n\n| Operator | Syntax | Description |\n| :--- | :--- | :--- |\n| **and** | `a and b` | True if both `a` and `b` are true. |\n| **or** | `a or b` | True if either `a` or `b` is true. |\n| **xor** | `a xor b` | True if exactly one of `a` or `b` is true. |\n| **not** | `not a` | True if `a` is false. |\n| **implies**| `a implies b`| False only if `a` is true and `b` is false. |\n\n*Example: A premium customer must have a discount.*\n```ocl\ncontext Customer inv:\n  self.premium implies (self.discount > 0)\n```\n\n##### The `if-then-else` Expression\nUnlike in many programming languages, `if` in OCL is not a statement but an **expression** that always returns a value.\n\n```ocl\ncontext Customer\n  def: customerCategory: String =\n    if self.premium then\n      'High Value'\n    else\n      'Standard'\n    endif\n```\n\n::: {.callout-warning icon=\"true\" title=\"Important Rules for `if` expressions\"}\n* **The `else` clause is mandatory.** Since `if` is an expression, it must always result in a value, so the `else` part can never be omitted.\n* **Type Conformance.** The type of the `if` expression is the most specific common supertype of the `then` expression and the `else` expression.\n:::\n\n##### A Note on Evaluation\nOCL has a very specific rule for evaluating boolean expressions that differs from many common programming languages.\n\n::: {.callout-warning icon=\"true\" title=\"No Short-Circuit Evaluation\"}\nThe logical operators `and`, `or`, and `xor` in OCL are **strict**. This means that **both operands are always evaluated**, even if the result of the first operand is enough to determine the outcome. There is no \"short-circuit\" or \"lazy\" evaluation. This is a common source of errors, especially when dealing with potentially null values.\n:::\n\n#### Relational, Arithmetic, and String Operators\nOCL provides a rich set of standard operators for the primitive types, allowing for the construction of detailed and precise expressions.\n\n##### Relational Operators\nThese operators are used for comparison and work across most primitive types to produce a `Boolean` result.\n\n| Operator | Description |\n| :--- | :--- |\n| **`=`** | Equality |\n| **`<>`** | Inequality (not equal) |\n| **`<`** | Less than |\n| **`>`** | Greater than |\n| **`<=`** | Less than or equal to |\n| **`>=`** | Greater than or equal to |\n\n##### Arithmetic Operators for (`Integer` and `Real`)\nOCL provides a standard library of arithmetic functions for numerical types.\n\n| Operator | Description |\n| :--- | :--- |\n| **`+`, `-`, `*`, `/`** | Addition, Subtraction, Multiplication, Division |\n| **`abs()`** | Absolute value |\n| **`floor()`**, **`round()`** | Floor and Rounding functions |\n| **`max(n)`**, **`min(n)`** | The maximum or minimum of two numbers |\n| **`mod(n)`** | Modulo operation |\n\n##### Operators for Strings (`String`)\nOCL includes a powerful set of operations for manipulating strings.\n\n| Operation | Description | Example |\n| :--- | :--- | :--- |\n| **`size()`** | Returns the number of characters in the string. | `'hello'.size() = 5` |\n| **`concat(s2)`**| Concatenates another string `s2`. | `'hello'.concat(' world')` results in `'hello world'` |\n| **`toUpper()`** | Converts the string to uppercase. | `'hello'.toUpper()` results in `'HELLO'` |\n| **`toLower()`** | Converts the string to lowercase. | `'HELLO'.toLower()` results in `'hello'` |\n| **`substring(i1, i2)`** | Returns the substring from index `i1` to `i2`. | `'hello'.substring(2, 4)` results in `'ell'` |\n\n*Example: An invariant stating that a car group's category must be a single uppercase letter.*\n```ocl\ncontext CarGroup inv:\n  self.category.size() = 1 and self.category = self.category.toUpper()\n```\n\n#### Operator Precedence\n\nOCL defines a strict order of precedence to determine how complex expressions are evaluated. The following table lists the operators in decreasing order of priority, from highest (evaluated first) to lowest (evaluated last).\n\n| Priority | Operator(s) | Description |\n| :--- | :--- | :--- |\n| **1** (Highest) | `@pre` | Time marker (used in post-conditions) |\n| **2** | `.` , `->` | Navigation (dot and arrow) |\n| **3** | `not` , `-` | Unary operators (negation) |\n| **4** | `*` , `/` | Multiplication, Division |\n| **5** | `+` , `-` | Addition, Subtraction (binary) |\n| **6** | `if-then-else-endif`| Conditional expression |\n| **7** | `=` , `<>` , `>` , `<` , `>=` , `<=` | Relational operators |\n| **8** | `and` , `or` , `xor` | Logical operators |\n| **9** | `implies` | Logical implication |\n| **10** (Lowest)| `in` | (Not covered yet) |\n\n::: {.callout-tip icon=\"true\" title=\"Best Practice: Use Parentheses\"}\nEven if you know the precedence rules, it is always a good practice to use parentheses `()` to make your expressions explicit and easier to read. This avoids any ambiguity for you and for others who will read your model.\n:::\n\n### The `context` and `self` Keywords\n\nEvery OCL constraint is anchored to a specific element in the UML model. The **`context`** keyword declares this anchor, defining the perspective from which the OCL expression will be evaluated. Within this context, the keyword **`self`** always refers to the specific instance of the element being constrained.\n\nOCL defines three primary types of context:\n\n#### Classifier Context\n\nThis is the most common context, used for defining **invariants**. The context is a classifier, typically a class, and `self` refers to an instance of that class.\n\n**Syntax:** `context <ClassName>`\n```ocl\ncontext Customer inv:\n  self.discount >= 0\n```\n\n#### Operation Context\n\nThis context is used to define **preconditions** and **postconditions** for an operation. The context is a specific operation within a class, and `self` refers to the instance of the class on which the operation is being called.\n\n**Syntax:** `context <ClassName>::<operationName>(...)`\n```ocl\ncontext Rental::extendRental(newDate: Date)\n  pre: self.state = 'active'\n```\n\n#### 3. Attribute Context\n\nThis context is used to define constraints on an attribute, typically for **derived values** or **initial values**. The context is a specific attribute within a class, and `self` refers to the instance of the class that owns the attribute.\n\n**Syntax:** `context <ClassName>::<attributeName>: <Type>`\n```ocl\ncontext Customer::isPrivileged: Boolean\n  derive: self.premium = true and self.discount > 10\n```\n\n### Writing Constraints: Invariants\n\nThe most common type of constraint you will write in OCL is the **invariant**.\n\n::: {.callout-note icon=\"true\" title=\"What is an Invariant?\"}\nAn invariant is a constraint that must be **true** for all instances of a class at **all times** during the system's execution. It defines a condition of integrity that can never be violated. If an operation causes an invariant to become false, the system is considered to be in an invalid state.\n:::\n\n#### Syntax\n\nThe general syntax for an invariant is straightforward:\n\n**`context`** `<Classifier>` **`inv`** `[`<constraint_name>`]:`\n  `<boolean_expression>`\n\n* **`context <Classifier>`**: Specifies the class to which the invariant applies.\n* **`inv`**: The stereotype indicating this is an invariant.\n* **`[<constraint_name>]`**: An optional but highly recommended name for the constraint.\n* **`<boolean_expression>`**: The OCL expression that must always evaluate to `true`.\n\n\n#### Invariant Examples\n\nLet's illustrate with a few examples based on our car rental system.\n\n##### Example 1: Simple Attribute Constraint\n\nA very common use for invariants is to restrict the possible values of an attribute.\n\n* **Rule:** A customer's discount must be a positive value.\n```ocl\ncontext Customer inv:\n  self.discount >= 0\n```\n\n##### Example 2: Constraint Across an Association\nInvariants are powerful for defining rules that involve multiple, associated classes.\n\n* **Rule:** A car that is currently assigned to an active rental cannot be part of a `CarGroup` marked as 'in_maintenance'.\n```ocl\ncontext Car inv:\n  self.rental->exists(r | r.state = 'active') implies \n    self.carGroup.category <> 'in_maintenance'\n```\n##### Example 3: Constraint with Inheritance\nInvariants can also enforce rules related to a class hierarchy.\n\n* **Rule:** A customer who is on the blacklist (i.e., is of type `BlackListed`) cannot have any active rentals.\n```ocl\ncontext Customer inv:\n  self.oclIsTypeOf(BlackListed) implies\n    self.rental->select(r | r.state = 'active')->isEmpty()\n```\n\n### Writing Contracts: Preconditions and Postconditions\n\nWhile invariants define the rules for a class's state, **preconditions** and **postconditions** define a **contract** for its operations. They specify what an operation requires to run and what it guarantees to accomplish.\n\n::: {.callout-note icon=\"true\" title=\"What are Preconditions and Postconditions?\"}\n* A **precondition** is a constraint that must be `true` **before** an operation is executed. It is the responsibility of the *caller* to satisfy the precondition. If it's false, the operation should not be called.\n* A **postcondition** is a constraint that must be `true` **after** an operation has successfully completed. It is the responsibility of the *operation itself* to establish the postcondition.\n:::\n\n#### Syntax\n\nThe syntax is similar to invariants, but the context is an operation, and the stereotypes are `pre` and `post`.\n\n**`context`** `<Classifier>::<operationName>(...)`\n  **`pre`** `[`<constraint_name>`]:` `<boolean_expression>`\n  **`post`** `[`<constraint_name>`]:` `<boolean_expression>`\n\n\n##### Precondition Example\n\nA precondition specifies the conditions under which an operation can be legally called.\n\n* **Rule:** A customer can only be added to the blacklist if they are not already on it.\n```ocl\ncontext Customer::addToBlackList(d: Date)\n  pre is_not_already_blacklisted:\n    self.oclIsTypeOf(BlackListed) = false\n```\n\n**Explanation:** This contract states that before calling `addToBlackList` on a `Customer` object, that object must not already be of the type `BlackListed`.\n\n\n\n##### Postcondition Example and the `@pre` Keyword\n\nA postcondition specifies the state of the system after the operation has finished. A crucial tool for this is the `@pre` keyword, which allows you to refer to a value as it was *before* the operation started.\n\n* **Rule:** After a customer is successfully added to the blacklist, they must be of the type `BlackListed`.\n\n```ocl\ncontext Customer::addToBlackList(d: Date)\n  post is_now_blacklisted:\n    self.oclIsTypeOf(BlackListed) = true\n```\nHere's a more complex example using `@pre`:\n\n* **Rule:** After a rental is extended, the new end date must be the one provided, and the number of associated cars must not have changed.\n```ocl\ncontext Rental::extendRental(newDate: Date)\n  post end_date_is_updated:\n    self.endingDate = newDate\n  post number_of_cars_is_unchanged:\n    self.assignedCar->size() = self.assignedCar@pre->size()\n```\n**Explanation:**\n\n* The first postcondition checks the new value of `endingDate`.\n* The second postcondition is critical: it uses `self.assignedCar@pre` to refer to the collection of cars *before* the operation ran and ensures its size has not changed. This prevents unintended side effects.\n\n\n### Initial and Derived Values, Query and Body Definitions\n\nBeyond invariants and contracts, OCL can be used to precisely define how attributes and operations get their values.\n\n#### `init`: Specifying Initial Values\n\nThe **`init`** stereotype allows you to define a constraint for the initial value of an attribute when an object is created. This is more powerful than a simple default value because you can use a complex OCL expression.\n\n**Syntax:** `context <ClassName>::<attributeName>: <Type> init: <expression>`\n\n*Example: When a `Rental` object is created, its `state` is initialized to 'planned'.*\n```ocl\ncontext Rental::state: String\n  init: 'planned'\n```\n#### `derive`: Specifying Derived Values\n\nThe **`derive`** stereotype is used for attributes whose value is not stored but is always calculated based on other properties of the model. This is used for derived attributes, which are often denoted with a `/` in front of their name in a class diagram.\n\n**Syntax:** `context <ClassName>::<attributeName>: <Type> derive: <expression>`\n\n*Example: A customer is considered \"privileged\" if they are premium and have a discount greater than 10.*\n```ocl\ncontext Customer::isPrivileged: Boolean\n  derive: self.premium = true and self.discount > 10\n```\n\n#### `def`: Defining Query Operations\n\nThe **`def`** stereotype allows you to define the body of a query operation directly in OCL. This is useful for specifying operations that retrieve information without changing the system's state.\n\n**Syntax:** `context <ClassName> def: <operationName>(): <ReturnType> = <expression>`\n\n*Example: Defining an operation that returns the set of all active rentals for a customer.*\n```ocl\ncontext Customer\n  def: getActiveRentals(): Set(Rental) =\n    self.rental->select(r | r.state = 'active')\n```\n\n#### `body`: Defining Operation Bodies\n\nWhile `def` is used to define a new query operation not present in the UML model, the **`body`** stereotype is used to provide a **concrete implementation** for an operation that is already **declared** in a class diagram.\n\nThis is particularly useful when you want to formally specify the result of a query operation without leaving its logic ambiguous.\n\n**Syntax:** `context <ClassName>::<operationName>(): <ReturnType> body: <expression>`\n\n*Example: Defining the body for a `getDiscountedPrice()` operation on the `Rental` class.*\n```ocl\ncontext Rental::getDiscountedPrice(): Real\n  body: self.price * (1 - self.customer.discount/100.0)\n```\n**Explanation:**\nThis OCL constraint provides the implementation for the `getDiscountedPrice()` operation. It specifies that the returned `Real` value is calculated by taking the rental's base `price` and applying the `discount` associated with the `customer`. Any programming language implementation of this class would now have a formal specification to follow for this method.\n\n\n### Navigating the Model\n\nThe primary power of OCL comes from its ability to navigate through a class diagram, starting from a context instance (`self`) to access its attributes, call its operations, and traverse its associations to reach other objects.\n\n#### Accessing Properties and Traversing Associations\n\nNavigation is performed using the dot (`.`) notation.\n\n* **Accessing Attributes:** `self.age`\n* **Calling Operations:** `self.getAge()` (Note: operations must be query-only and have no side effects).\n* **Traversing an Association:** To navigate, you use the **role name** at the opposite end of the association. If the role is unnamed, you use the name of the class itself, starting with a lowercase letter.\n\n![A diagram showing a Person class associated with a Company class.](images/navigation-person-company.png){width=\"60%\"}\n\n```ocl\ncontext Person inv:\n  -- Navigates from Person to Company via the 'employer' role.\n  -- The result is a single object of type Company.\n  self.employer\n```\n#### Navigation From a Collection\n\nThis is a fundamental concept in OCL. When you start a navigation from an expression that results in a collection, the navigation is performed on **each element** of that collection. The final result is a new collection containing all the individual results.\n\n![A diagram showing navigation from an Administration object to a collection of Person objects.](images/navigation-administration-person.png){width=\"60 %\"}\n\n```ocl\ncontext Administration inv:\n  -- 1. self.persons returns a Set of Person objects: Set{p1, p2}\n  self.persons\n\n  -- 2. Navigating to 'name' from this Set returns a Bag of all names.\n  -- The result is Bag{'jack', 'lisa'}\n  self.persons.name\n\n  -- 3. Navigating to 'age' returns a Bag of all ages.\n  -- The result is Bag{30, 22}\n  self.persons.age\n```\n\n**Note:** When you navigate from a `Set` to an attribute, the result is a `Bag`, not a `Set`, because different objects in the original set could have the same value for that attribute.\n\n#### Chained Navigation\n\nYou can chain navigations together to traverse complex paths in your model. The rules of collection navigation apply at each step.\n\n![A diagram showing chained navigation from Rental to AssignedCar, then CarGroup, then category.](images/navigation-chained-example.png){width=\"60%\"}\n\n```ocl\ncontext Administration inv:\n  -- self.persons -> Set{p1, p2}\n  -- self.persons.children returns a Bag containing all children of p1 and p2.\n  self.persons.children\n\n  -- This expression first gets all children (a Bag),\n  -- then for each child, it navigates to their parents (a Set of 2 Persons).\n  -- The final result is a Bag containing all the parents of all the children.\n  self.persons.children.parent\n  ```\n  \n##### A Note on Flattening Collections\n\nWhen a navigation path involves multiple \"to-many\" associations, OCL automatically simplifies the result.\n\nConsider the expression from the slide:\n```ocl\ncontext Administration inv:\n  self.persons.car\n```\n\nLet's break this down:\n\n1.  `self.persons` returns a `Set` of `Person` objects.\n2.  For each `Person` in that set, `.car` returns a `Set` of `Car` objects (because the multiplicity is `*`).\n3.  The result is therefore a collection of collections, for example: `Bag{ Set{car1}, Set{car2, car3} }`.\n\nInstead of forcing you to work with this complex nested structure, OCL **automatically flattens** it into a single `Bag` containing all the elements: `Bag{car1, car2, car3}`.\n\nThis is why you can continue the navigation chain directly. The expression `self.persons.car.type` works as follows:\n\n1.  `self.persons.car` produces a flattened `Bag` of all cars owned by all persons.\n2.  The navigation `.type` is then applied to each `Car` in this flattened bag.\n3.  The final result is a `Bag` of all the `type` strings from all those cars.\n\n\n### Working with Collections\n\nBecause navigation often results in collections, OCL provides a rich set of predefined operations to query and manipulate them. These operations are always invoked using the arrow (`->`) notation.\n\n#### Basic Operations\n\nThese operations provide fundamental information about a collection or check for the presence of specific elements.\n\n* **`size()`**: Returns the number of elements.\n* **`isEmpty()` / `notEmpty()`**: Checks if the collection is empty or not.\n* **`includes(obj)` / `excludes(obj)`**: Checks if a specific object is in the collection.\n* **`includesAll(coll2)` / `excludesAll(coll2)`**: Checks if all (or no) elements of another collection `coll2` are present.\n* **`count(obj)`**: Counts the occurrences of an object in the collection (most useful for `Bag` and `Sequence`).\n\n*Example: An invariant stating that a Person must have exactly two parents.*\n```ocl\ncontext Person inv:\n  self.parent->size() = 2\n```\n\n#### Iterators: The Power of Collections\nThe most powerful feature of OCL collections is the ability to use **iterators**. An iterator is an operation that evaluates an expression for each element in a collection, allowing you to filter, transform, or verify its properties.\n\n##### `select` and `reject` (Filtering)\nThese are the primary tools for filtering a collection. They return a new collection containing only the elements that satisfy (or don't satisfy) a condition.\n\n* **`select(v | boolean_expression)`**: Returns a sub-collection with elements for which the expression is `true`.\n* **`reject(v | boolean_expression)`**: Returns a sub-collection with elements for which the expression is `false`.\n\n*Example: Select all rentals for a customer that are currently active.*\n```ocl\ncontext Customer\n  def: getActiveRentals(): Set(Rental) =\n    self.rental->select(r | r.state = 'active')\n```\n\n##### `forAll` and `exists` (Quantifiers)\nThese iterators evaluate a condition over a collection and return a single `Boolean` value. They are essential for writing precise invariants.\n\n* **`forAll(v | boolean_expression)`**: Returns `true` if the expression is true for **all** elements.\n* **`exists(v | boolean_expression)`**: Returns `true` if the expression is true for **at least one** element.\n\n*Example: An invariant stating that all cars in a \"Luxury\" car group must be of the brand \"Mercedes\".*\n```ocl\ncontext CarGroup inv:\n  self.category = 'Luxury' implies\n    self.car->forAll(c | c.brand = 'Mercedes')\n```\n\n##### `collect` (Transformation)\nThe `collect` iterator transforms a collection by applying an expression to each of its elements. It returns a new `Bag` containing the results (similar to a `map` function).\n\n*Example: Get a collection of all the registration numbers of the cars rented by a customer.*\n```ocl\ncontext Customer\n  def: allRentedCarRegNums(): Bag(String) =\n    self.rental.assignedCar.car->collect(c | c.regNum)\n```\n\n\n#### `closure` (Transitive Closure)\n\nThe `closure` iterator is an advanced and extremely powerful operation that calculates the **transitive closure** of a relationship over a collection. In simpler terms, it allows you to repeatedly navigate through an association until no more new elements can be discovered.\n\nThis is the perfect tool for working with hierarchical or graph-like structures, such as finding all descendants of a person in a family tree or all sub-parts in an assembly.\n\n**Syntax:** `collection->closure( v | navigation_expression )`\n\n*Example: Find all descendants of a person (their children, their children's children, and so on).*\n\n![A class diagram showing a reflexive 'children' association on the Person class.](images/person-children-example.png){width=\"60%\" fig-align=\"center\"}\n\n```ocl\ncontext Person\n  def: getAllDescendants(): Set(Person) =\n    self.children->closure(p | p.children)\n```\n\n**Explanation:**\n\n1.  `self.children`: The expression starts with the set of the person's direct children.\n2.  `->closure(p | p.children)`: The `closure` iterator then takes each person `p` from that set, finds their own `children`, adds them to the result, and repeats this process until no new descendants can be found. The final result is a flattened `Set` containing all descendants at every level.\n\n### Operations on All Objects (`OclAny`)\n\nBecause `OclAny` is the supertype of all types in your model, the operations it defines are available on **every object**. These are fundamental tools for checking equality, types, and for casting.\n\n#### Equality (`=` and `<>`)\nThese operators check if two expressions refer to the exact same object instance.\n\n* `a = b`: Returns `true` if `a` and `b` are the same object.\n* `a <> b`: Returns `true` if `a` and `b` are different objects.\n\n\n#### Type Checking: `oclIsTypeOf` vs. `oclIsKindOf`\n\nThese two operations are crucial for writing constraints in a generalization hierarchy, but they have a very important semantic difference.\n\n* **`oclIsTypeOf(Type)`**: Returns `true` only if the object is an instance of that **exact** type, and not a subtype.\n* **`oclIsKindOf(Type)`**: Returns `true` if the object is an instance of that type **or any of its subtypes**.\n\nLet's consider the following hierarchy:\n\n![A generalization hierarchy showing Student and Professor inheriting from Person.](images/generalization.png){fig-alt=\"A generalization hierarchy showing Student and Professor inheriting from Person.\" width=\"70%\" fig-align=\"center\"}\n\nThe following examples illustrate the difference:\n\n```ocl\ncontext Person inv:\n  self.oclIsKindOf(Person)   -- returns true\n  self.oclIsTypeOf(Person)   -- returns true\n  self.oclIsKindOf(Student)  -- returns false\n  self.oclIsTypeOf(Student)  -- returns true\n```\n\n```ocl\ncontext Student inv:\n  self.oclIsKindOf(Person)   -- returns true\n  self.oclIsTypeOf(Person)   -- returns false\n  self.oclIsKindOf(Student)  -- returns true\n  self.oclIsTypeOf(Student)  -- returns true\n  self.oclIsKindOf(Professor)-- returns false\n  self.oclIsTypeOf(Professor)-- returns false\n```\n\n#### Type Casting: `oclAsType`\nThis operation allows you to cast an object to a more specific subtype. This is necessary when you need to access attributes or operations that are only defined on that subtype.\n\n* **`oclAsType(Type)`**: Casts the object to the specified `Type`. If the object is not actually of that type or one of its subtypes, the expression result is `invalid`.\n\n*Example: An invariant on a Person object, stating that if that person is a Student, their student ID must not be empty.*\n\n```ocl\ncontext Person inv:\n  self.oclIsKindOf(Student) implies\n    self.oclAsType(Student).studentId->notEmpty()\n```\n**Explanation:** We first check if the `Person` is a `Student` (or a subtype). If so, we cast `self` to `Student` to be able to safely access the `studentId` attribute.\n\n#### Handling Undefined Values (`OclVoid`)\n\nIn OCL, the value `null` has a specific type: **`OclVoid`**. It is used to represent an object that does not exist or an attribute that has not been set.\n\n* **`oclIsUndefined()`**: Returns `true` if the object is `null`.\n* **`oclIsInvalid()`**: Returns `true` if an expression is ill-formed (e.g., navigating from `null`).\n\n*Example: An invariant stating that every `Rental` must be associated with a `Customer` (i.e., the `driver` role cannot be empty).*\n```ocl\ncontext Rental inv:\n  self.driver.oclIsUndefined() = false\n```\nThis is a robust way to check that a mandatory association (1..*) is respected.\n\n---\n\n### Special Operations: `allInstances` and `oclIsNew`\n\nTo conclude our overview of OCL, let's look at two special operations that operate at a meta-level: one that queries all objects of a certain type, and another that checks for an object's creation within a postcondition.\n\n#### `allInstances()`: Accessing All Objects of a Type\n\nThe `allInstances()` operation is unique because it is called directly on a **class**, not on an instance (`self`). It returns a `Set` containing all instances of that specific class that currently exist in the system at the time of evaluation.\n\n**Syntax:** `<ClassName>.allInstances()`\n\nThis operation is extremely powerful for writing global invariants that must hold true across the entire system.\n\n*Example: An invariant to enforce that every employee in the system has a unique employee ID.*\n```ocl\ncontext Employee inv:\n  Employee.allInstances()->forAll(e1, e2 | \n    e1 <> e2 implies e1.employeeId <> e2.employeeId\n  )\n```\n\n::: {.callout-warning icon=\"true\" title=\"Use with Caution\"}\nThe `allInstances()` operation can be computationally expensive and conceptually dangerous. Using it on a type with a potentially huge or even infinite number of instances (like `Integer` or `String`) can lead to problems. It is best reserved for application-specific classes where the number of instances is manageable.\n:::\n\n#### `oclIsNew()`: Checking Object Creation\n\nThe `oclIsNew()` operation is a special tool used **only in postconditions**. It returns `true` if the object on which it is called was created during the execution of the operation specified in the context.\n\n*Example: A postcondition for a `createRental(...)` operation on the `Customer` class, stating that a new `Rental` object has been created and is now linked to the customer.*\n```ocl\ncontext Customer::createRental(...)\n  post: let newRental : Rental = self.rental->select(r | r.oclIsNew())->asSequence()->first() in\n    newRental.oclIsUndefined() = false and newRental.customer = self\n```\n**Explanation:** This advanced postcondition first finds the new `Rental` object created during the operation using `oclIsNew()` and then asserts that this new rental exists and is correctly associated with the current customer (`self`).","srcMarkdownNoYaml":"\n\nThis chapter introduces the **Object Constraint Language (OCL)**, a formal language used to add precise and unambiguous rules to UML models. We will explore why UML diagrams alone are often insufficient and how OCL helps to create more rigorous and verifiable software specifications.\n\n## The Need for Precision: What UML Diagrams Don't Say\n\nAs we have seen, UML diagrams, especially Class Diagrams, are powerful tools for modelling the static structure of a system. However, they cannot capture all the business rules and constraints that govern a system's behaviour. A diagram can be syntactically correct but still allow for situations that are logically incorrect or violate business rules.\n\nConsider the following class diagram for a car rental system:\n\n![A class diagram for a car rental system.](images/car-rental-cd.png){fig-alt=\"Class diagram for a car rental system.\" width=\"100%\"}\n\nThis diagram leaves many important questions unanswered:\n\n* Can a customer who is on the blacklist rent a new car?\n* How is the price of a rental calculated?\n* Can the pickup and drop-off branches be different?\n* Should a driver's license be valid for the entire rental period?\n\nWhile we could add this information in natural language, this approach is notoriously unreliable. Natural language specifications are prone to what are often called the **\"7 Deadly Sins\"**:\n\n::: {.callout-warning icon=\"false\" title=\"The 7 Deadly Sins of Natural Language Specification\"}\n* **Ambiguity:** A statement can be interpreted in multiple ways.\n* **Contradiction:** Two or more rules in the specification conflict with each other.\n* **Silence (Incompleteness):** A required rule or feature is not mentioned at all.\n* **Noise:** The text contains irrelevant information that obscures the actual requirements.\n* **Over-specification:** The text unnecessarily describes implementation details (\"how\") instead of requirements (\"what\").\n* **Vagueness:** The requirements are not stated precisely enough to be verified.\n* **Wishful Thinking:** A requirement is described that is impossible to implement.\n:::\n\nThese issues make automated verification impossible and lead to costly errors in implementation. To solve this, we need a formal, unambiguous way to express these rules, which is precisely the role of OCL.\n\n\n## Introduction to OCL\n\nTo solve the problems of ambiguity and imprecision, the **Object Constraint Language (OCL)** was created. It is the official standard from the OMG (Object Management Group) for adding formal constraints to UML models.\n\nOCL is a **declarative, textual, and formal language**. This means:\n\n* **Declarative:** You specify *what* should be true, not *how* to check it.\n* **Textual:** It integrates seamlessly with the graphical nature of UML diagrams.\n* **Formal:** It has a well-defined mathematical foundation, which removes ambiguity.\n\nIt is designed to be a middle ground: more precise than natural language, but less complex and easier to learn than purely mathematical formalisms.\n\n### Language Philosophy\n\nTo use OCL correctly, it is crucial to understand its core philosophy: OCL is a **pure specification language**, not a programming language. This has two major consequences:\n\n::: {.callout-note icon=\"true\" title=\"No Side Effects\"}\nAn OCL expression is a query that can only **read** the state of the model, it can **never change it**. You cannot use OCL to assign a value to an attribute, create an object, or call an operation that modifies the system's state. This guarantees that checking a constraint will never alter the system you are verifying.\n:::\n\n::: {.callout-note icon=\"true\" title=\"Instantaneous Evaluation\"}\nThe evaluation of an OCL expression is considered to be **instantaneous**. This is a powerful abstraction that means the state of the system is \"frozen\" during the evaluation of a constraint. You don't have to worry about other parts of the system changing while your expression is being checked, which greatly simplifies writing complex rules.\n:::\n\n## Main Applications of OCL\n\nOCL is a versatile language used to add precision to a model in several key ways. Let's explore its main applications with concrete examples based on our car rental system.\n\n1.  **Constraining Models (Invariants):**\n    The primary use of OCL is to write **invariants**. An invariant is a rule that must be true for all instances of a class at all times.\n\n    *Example: A customer's discount must always be a positive value.*\n    ```ocl\n    context Customer inv:\n      self.discount >= 0\n    ```\n    **Explanation:** This simple invariant ensures that for any `Customer` object, the `discount` attribute (which is an `Integer` in the diagram) can never be negative.\n\n2.  **Specifying Contracts (Preconditions & Postconditions):**\n    OCL is used to define formal contracts for operations. A **precondition** must be true *before* an operation is executed, and a **postcondition** must be true *after*.\n\n    *Example: To extend a rental, its state must be 'active'.*\n    ```ocl\n    context Rental::extendRental(newDate: Date)\n      pre must_be_active:\n        self.state = 'active'\n    ```\n    **Explanation:** This precondition checks that the `state` attribute of the `Rental` instance is equal to the string `'active'`. The operation cannot be called otherwise.\n\n3.  **Specifying Derived Values:**\n    OCL can define how the value of an attribute should be calculated from other information. This is for values that are not stored directly.\n\n    *Example: Let's define a derived boolean attribute `isPrivileged` for a `Customer`.*\n    ```ocl\n    context Customer derive: isPrivileged: Boolean =\n      self.premium = true and self.discount > 10\n    ```\n    **Explanation:** This rule states that a customer is considered \"privileged\" if and only if their `premium` status is true and their `discount` is greater than 10.\n\n4.  **Defining Queries:**\n    You can use OCL to navigate through the model to retrieve information, much like a query.\n\n    *Example: A query to get the set of all active rentals for a specific customer.*\n    ```ocl\n    context Customer\n      def: getActiveRentals(): Set(Rental) =\n        self.rental->select(r | r.state = 'active')\n    ```\n    **Explanation:** This defines a new operation `getActiveRentals` on the `Customer` class. It navigates to the customer's collection of `rental` and uses the `select` iterator to return a new set containing only those rentals whose `state` is 'active'.\n\n\n## Fundamental OCL Concepts\n\nTo write meaningful constraints, we first need to understand the two pillars of the OCL language: its **robust typing system**, and its **precise syntax and the formal semantics** that underpin it.\n\n\n\n### OCL is a Typed Language\n\nEvery element in OCL, from an attribute to the result of a complex navigation, has a **type**. This strong typing system ensures that expressions are well-formed and prevents errors, much like in languages like Java. OCL's type system is built from three sources:\n\n#### Primitive Types\nOCL includes four fundamental, built-in types that are the basis for most expressions:\n\n* `Integer` (e.g., `5`, `-10`)\n* `Real` (e.g., `3.14`, `-0.5`)\n* `String` (e.g., `'active'`, `'John Doe'`)\n* `Boolean` (`true`, `false`)\n\n#### UML Model Types\nThis is a powerful feature: **every classifier you define in your UML model automatically becomes a new type in OCL**. If you have a class named `Customer` in your diagram, `Customer` becomes a valid type in your OCL expressions. This allows you to write constraints that are perfectly tailored to your specific domain.\n\n#### Collection Types\nBecause navigating associations often results in multiple objects, OCL has a rich set of built-in collection types to handle them. The collection is an abstract type with four concrete subtypes:\n\n| Collection Type | Order Matters? | Duplicates Allowed? | Example Literal |\n| :--- | :--- | :--- | :--- |\n| **`Set(T)`** | No | No | `Set{1, 2, 3}` |\n| **`OrderedSet(T)`**| Yes | No | `OrderedSet{1, 2, 3}`|\n| **`Bag(T)`** | No | Yes | `Bag{1, 2, 2, 3}` |\n| **`Sequence(T)`**| Yes | Yes | `Sequence{1, 3, 2, 3}`|\n\nBy default, navigating a `*` multiplicity association returns a `Set`. Understanding these collection types is essential, as most non-trivial OCL expressions involve manipulating collections.\n\n### Special OCL Types\n\nBeyond the primitive and model-based types, OCL provides a set of special, built-in classifiers that are essential for writing advanced constraints. The hierarchy of these types is shown in the diagram below.\n\n![A class diagram showing the OCL Type Hierarchy, with Classifier at the top.](images/ocl-type-hierarchy.png){fig-alt=\"The OCL Type Hierarchy\" width=\"100%\"}\n\n\nLet's explore the most important ones:\n\n* **`OclAny`**: This is the supertype of all other types in OCL (except for collection and tuple types). Any operation defined on `OclAny` (like `oclIsTypeOf()`) is available on all objects in your model.\n\n* **`OclVoid`**: This type has only one possible value: `null`. It is used to check if a property has been set or not. Any expression that results in a division by zero, for example, will evaluate to `null`. You can check for this value using the `oclIsUndefined()` operation.\n\n* **`OclInvalid`**: This type has only one value: `invalid`. It is used to represent the result of an ill-formed expression, for instance, when trying to navigate from `null`. It is a subtype of all other types, meaning an `invalid` value can \"poison\" an entire expression. You can check for it with `oclIsInvalid()`.\n\n* **`TupleType`**: A tuple is a structured type that groups together several named parts, each with its own type. It's similar to a struct or a record and is very useful for returning multiple values from a query operation.\n\n    ```ocl\n    Tuple{name: String = 'Mikel', id: Integer = 123}\n    ```\n\n* **`OclState`**: This special type is used exclusively within state machine diagrams. The operation `oclIsInState(stateName: OclState)` allows you to write a constraint that checks if an object is currently in a specific state, which is very powerful for defining state-dependent invariants.\n\n* **`OclMessage`**: Used in interaction diagrams (like sequence diagrams), this type allows you to write constraints on the messages exchanged between objects. For example, you can check if a specific message has been sent or received.\n\n\n### Type Conformance and Subtyping\n\nThe OCL type system is not flat, it has a rich hierarchy that defines which types are considered subtypes of others. This is known as **type conformance**. Understanding these rules is crucial, as it determines when a value of one type can be used where a value of another type is expected.\n\nThe main rules of type conformance in OCL are as follows:\n\n1.  For primitive numbers, the hierarchy is logical: `UnlimitedNatural` is a subtype of `Integer`, which is a subtype of `Real`.\n2.  `OclAny` is the ultimate supertype for all non-collection types. This means any object from your UML model is conformant to `OclAny`.\n3.  The hierarchy of your **UML model types** mirrors the generalization (inheritance) relationships in your class diagram. If you have a `Student` class that inherits from `Person`, then `Student` is a subtype of `Person` in OCL.\n4.  For collections, `Set(T)`, `Bag(T)`, `Sequence(T)`, and `OrderedSet(T)` are all subtypes of the general `Collection(T)` type.\n5.  The special types have their own rules:\n    * `OclVoid` (representing `null`) is a subtype of all other types (except `OclInvalid`).\n    * `OclInvalid` is the ultimate subtype, it is a subtype of *every other type*. This explains why an `invalid` value can propagate through and \"poison\" any expression.\n\nThis hierarchy is visualized in the diagram below.\n\n![A class diagram showing the OCL Type Hierarchy and a list of the 7 conformance rules.](images/type-conformance-rules.png){fig-alt=\"The OCL Type Hierarchy and its conformance rules.\" width=\"30%\"}\n\n### Standard OCL Operators\n\nLike any language, OCL comes with a standard set of operators to perform logical, relational, and arithmetic operations. These are the building blocks for creating complex boolean expressions within your constraints.\n\n#### Logical Operators\nOCL supports the standard boolean logic operators. Note that they are written in lowercase.\n\n| Operator | Syntax | Description |\n| :--- | :--- | :--- |\n| **and** | `a and b` | True if both `a` and `b` are true. |\n| **or** | `a or b` | True if either `a` or `b` is true. |\n| **xor** | `a xor b` | True if exactly one of `a` or `b` is true. |\n| **not** | `not a` | True if `a` is false. |\n| **implies**| `a implies b`| False only if `a` is true and `b` is false. |\n\n*Example: A premium customer must have a discount.*\n```ocl\ncontext Customer inv:\n  self.premium implies (self.discount > 0)\n```\n\n##### The `if-then-else` Expression\nUnlike in many programming languages, `if` in OCL is not a statement but an **expression** that always returns a value.\n\n```ocl\ncontext Customer\n  def: customerCategory: String =\n    if self.premium then\n      'High Value'\n    else\n      'Standard'\n    endif\n```\n\n::: {.callout-warning icon=\"true\" title=\"Important Rules for `if` expressions\"}\n* **The `else` clause is mandatory.** Since `if` is an expression, it must always result in a value, so the `else` part can never be omitted.\n* **Type Conformance.** The type of the `if` expression is the most specific common supertype of the `then` expression and the `else` expression.\n:::\n\n##### A Note on Evaluation\nOCL has a very specific rule for evaluating boolean expressions that differs from many common programming languages.\n\n::: {.callout-warning icon=\"true\" title=\"No Short-Circuit Evaluation\"}\nThe logical operators `and`, `or`, and `xor` in OCL are **strict**. This means that **both operands are always evaluated**, even if the result of the first operand is enough to determine the outcome. There is no \"short-circuit\" or \"lazy\" evaluation. This is a common source of errors, especially when dealing with potentially null values.\n:::\n\n#### Relational, Arithmetic, and String Operators\nOCL provides a rich set of standard operators for the primitive types, allowing for the construction of detailed and precise expressions.\n\n##### Relational Operators\nThese operators are used for comparison and work across most primitive types to produce a `Boolean` result.\n\n| Operator | Description |\n| :--- | :--- |\n| **`=`** | Equality |\n| **`<>`** | Inequality (not equal) |\n| **`<`** | Less than |\n| **`>`** | Greater than |\n| **`<=`** | Less than or equal to |\n| **`>=`** | Greater than or equal to |\n\n##### Arithmetic Operators for (`Integer` and `Real`)\nOCL provides a standard library of arithmetic functions for numerical types.\n\n| Operator | Description |\n| :--- | :--- |\n| **`+`, `-`, `*`, `/`** | Addition, Subtraction, Multiplication, Division |\n| **`abs()`** | Absolute value |\n| **`floor()`**, **`round()`** | Floor and Rounding functions |\n| **`max(n)`**, **`min(n)`** | The maximum or minimum of two numbers |\n| **`mod(n)`** | Modulo operation |\n\n##### Operators for Strings (`String`)\nOCL includes a powerful set of operations for manipulating strings.\n\n| Operation | Description | Example |\n| :--- | :--- | :--- |\n| **`size()`** | Returns the number of characters in the string. | `'hello'.size() = 5` |\n| **`concat(s2)`**| Concatenates another string `s2`. | `'hello'.concat(' world')` results in `'hello world'` |\n| **`toUpper()`** | Converts the string to uppercase. | `'hello'.toUpper()` results in `'HELLO'` |\n| **`toLower()`** | Converts the string to lowercase. | `'HELLO'.toLower()` results in `'hello'` |\n| **`substring(i1, i2)`** | Returns the substring from index `i1` to `i2`. | `'hello'.substring(2, 4)` results in `'ell'` |\n\n*Example: An invariant stating that a car group's category must be a single uppercase letter.*\n```ocl\ncontext CarGroup inv:\n  self.category.size() = 1 and self.category = self.category.toUpper()\n```\n\n#### Operator Precedence\n\nOCL defines a strict order of precedence to determine how complex expressions are evaluated. The following table lists the operators in decreasing order of priority, from highest (evaluated first) to lowest (evaluated last).\n\n| Priority | Operator(s) | Description |\n| :--- | :--- | :--- |\n| **1** (Highest) | `@pre` | Time marker (used in post-conditions) |\n| **2** | `.` , `->` | Navigation (dot and arrow) |\n| **3** | `not` , `-` | Unary operators (negation) |\n| **4** | `*` , `/` | Multiplication, Division |\n| **5** | `+` , `-` | Addition, Subtraction (binary) |\n| **6** | `if-then-else-endif`| Conditional expression |\n| **7** | `=` , `<>` , `>` , `<` , `>=` , `<=` | Relational operators |\n| **8** | `and` , `or` , `xor` | Logical operators |\n| **9** | `implies` | Logical implication |\n| **10** (Lowest)| `in` | (Not covered yet) |\n\n::: {.callout-tip icon=\"true\" title=\"Best Practice: Use Parentheses\"}\nEven if you know the precedence rules, it is always a good practice to use parentheses `()` to make your expressions explicit and easier to read. This avoids any ambiguity for you and for others who will read your model.\n:::\n\n### The `context` and `self` Keywords\n\nEvery OCL constraint is anchored to a specific element in the UML model. The **`context`** keyword declares this anchor, defining the perspective from which the OCL expression will be evaluated. Within this context, the keyword **`self`** always refers to the specific instance of the element being constrained.\n\nOCL defines three primary types of context:\n\n#### Classifier Context\n\nThis is the most common context, used for defining **invariants**. The context is a classifier, typically a class, and `self` refers to an instance of that class.\n\n**Syntax:** `context <ClassName>`\n```ocl\ncontext Customer inv:\n  self.discount >= 0\n```\n\n#### Operation Context\n\nThis context is used to define **preconditions** and **postconditions** for an operation. The context is a specific operation within a class, and `self` refers to the instance of the class on which the operation is being called.\n\n**Syntax:** `context <ClassName>::<operationName>(...)`\n```ocl\ncontext Rental::extendRental(newDate: Date)\n  pre: self.state = 'active'\n```\n\n#### 3. Attribute Context\n\nThis context is used to define constraints on an attribute, typically for **derived values** or **initial values**. The context is a specific attribute within a class, and `self` refers to the instance of the class that owns the attribute.\n\n**Syntax:** `context <ClassName>::<attributeName>: <Type>`\n```ocl\ncontext Customer::isPrivileged: Boolean\n  derive: self.premium = true and self.discount > 10\n```\n\n### Writing Constraints: Invariants\n\nThe most common type of constraint you will write in OCL is the **invariant**.\n\n::: {.callout-note icon=\"true\" title=\"What is an Invariant?\"}\nAn invariant is a constraint that must be **true** for all instances of a class at **all times** during the system's execution. It defines a condition of integrity that can never be violated. If an operation causes an invariant to become false, the system is considered to be in an invalid state.\n:::\n\n#### Syntax\n\nThe general syntax for an invariant is straightforward:\n\n**`context`** `<Classifier>` **`inv`** `[`<constraint_name>`]:`\n  `<boolean_expression>`\n\n* **`context <Classifier>`**: Specifies the class to which the invariant applies.\n* **`inv`**: The stereotype indicating this is an invariant.\n* **`[<constraint_name>]`**: An optional but highly recommended name for the constraint.\n* **`<boolean_expression>`**: The OCL expression that must always evaluate to `true`.\n\n\n#### Invariant Examples\n\nLet's illustrate with a few examples based on our car rental system.\n\n##### Example 1: Simple Attribute Constraint\n\nA very common use for invariants is to restrict the possible values of an attribute.\n\n* **Rule:** A customer's discount must be a positive value.\n```ocl\ncontext Customer inv:\n  self.discount >= 0\n```\n\n##### Example 2: Constraint Across an Association\nInvariants are powerful for defining rules that involve multiple, associated classes.\n\n* **Rule:** A car that is currently assigned to an active rental cannot be part of a `CarGroup` marked as 'in_maintenance'.\n```ocl\ncontext Car inv:\n  self.rental->exists(r | r.state = 'active') implies \n    self.carGroup.category <> 'in_maintenance'\n```\n##### Example 3: Constraint with Inheritance\nInvariants can also enforce rules related to a class hierarchy.\n\n* **Rule:** A customer who is on the blacklist (i.e., is of type `BlackListed`) cannot have any active rentals.\n```ocl\ncontext Customer inv:\n  self.oclIsTypeOf(BlackListed) implies\n    self.rental->select(r | r.state = 'active')->isEmpty()\n```\n\n### Writing Contracts: Preconditions and Postconditions\n\nWhile invariants define the rules for a class's state, **preconditions** and **postconditions** define a **contract** for its operations. They specify what an operation requires to run and what it guarantees to accomplish.\n\n::: {.callout-note icon=\"true\" title=\"What are Preconditions and Postconditions?\"}\n* A **precondition** is a constraint that must be `true` **before** an operation is executed. It is the responsibility of the *caller* to satisfy the precondition. If it's false, the operation should not be called.\n* A **postcondition** is a constraint that must be `true` **after** an operation has successfully completed. It is the responsibility of the *operation itself* to establish the postcondition.\n:::\n\n#### Syntax\n\nThe syntax is similar to invariants, but the context is an operation, and the stereotypes are `pre` and `post`.\n\n**`context`** `<Classifier>::<operationName>(...)`\n  **`pre`** `[`<constraint_name>`]:` `<boolean_expression>`\n  **`post`** `[`<constraint_name>`]:` `<boolean_expression>`\n\n\n##### Precondition Example\n\nA precondition specifies the conditions under which an operation can be legally called.\n\n* **Rule:** A customer can only be added to the blacklist if they are not already on it.\n```ocl\ncontext Customer::addToBlackList(d: Date)\n  pre is_not_already_blacklisted:\n    self.oclIsTypeOf(BlackListed) = false\n```\n\n**Explanation:** This contract states that before calling `addToBlackList` on a `Customer` object, that object must not already be of the type `BlackListed`.\n\n\n\n##### Postcondition Example and the `@pre` Keyword\n\nA postcondition specifies the state of the system after the operation has finished. A crucial tool for this is the `@pre` keyword, which allows you to refer to a value as it was *before* the operation started.\n\n* **Rule:** After a customer is successfully added to the blacklist, they must be of the type `BlackListed`.\n\n```ocl\ncontext Customer::addToBlackList(d: Date)\n  post is_now_blacklisted:\n    self.oclIsTypeOf(BlackListed) = true\n```\nHere's a more complex example using `@pre`:\n\n* **Rule:** After a rental is extended, the new end date must be the one provided, and the number of associated cars must not have changed.\n```ocl\ncontext Rental::extendRental(newDate: Date)\n  post end_date_is_updated:\n    self.endingDate = newDate\n  post number_of_cars_is_unchanged:\n    self.assignedCar->size() = self.assignedCar@pre->size()\n```\n**Explanation:**\n\n* The first postcondition checks the new value of `endingDate`.\n* The second postcondition is critical: it uses `self.assignedCar@pre` to refer to the collection of cars *before* the operation ran and ensures its size has not changed. This prevents unintended side effects.\n\n\n### Initial and Derived Values, Query and Body Definitions\n\nBeyond invariants and contracts, OCL can be used to precisely define how attributes and operations get their values.\n\n#### `init`: Specifying Initial Values\n\nThe **`init`** stereotype allows you to define a constraint for the initial value of an attribute when an object is created. This is more powerful than a simple default value because you can use a complex OCL expression.\n\n**Syntax:** `context <ClassName>::<attributeName>: <Type> init: <expression>`\n\n*Example: When a `Rental` object is created, its `state` is initialized to 'planned'.*\n```ocl\ncontext Rental::state: String\n  init: 'planned'\n```\n#### `derive`: Specifying Derived Values\n\nThe **`derive`** stereotype is used for attributes whose value is not stored but is always calculated based on other properties of the model. This is used for derived attributes, which are often denoted with a `/` in front of their name in a class diagram.\n\n**Syntax:** `context <ClassName>::<attributeName>: <Type> derive: <expression>`\n\n*Example: A customer is considered \"privileged\" if they are premium and have a discount greater than 10.*\n```ocl\ncontext Customer::isPrivileged: Boolean\n  derive: self.premium = true and self.discount > 10\n```\n\n#### `def`: Defining Query Operations\n\nThe **`def`** stereotype allows you to define the body of a query operation directly in OCL. This is useful for specifying operations that retrieve information without changing the system's state.\n\n**Syntax:** `context <ClassName> def: <operationName>(): <ReturnType> = <expression>`\n\n*Example: Defining an operation that returns the set of all active rentals for a customer.*\n```ocl\ncontext Customer\n  def: getActiveRentals(): Set(Rental) =\n    self.rental->select(r | r.state = 'active')\n```\n\n#### `body`: Defining Operation Bodies\n\nWhile `def` is used to define a new query operation not present in the UML model, the **`body`** stereotype is used to provide a **concrete implementation** for an operation that is already **declared** in a class diagram.\n\nThis is particularly useful when you want to formally specify the result of a query operation without leaving its logic ambiguous.\n\n**Syntax:** `context <ClassName>::<operationName>(): <ReturnType> body: <expression>`\n\n*Example: Defining the body for a `getDiscountedPrice()` operation on the `Rental` class.*\n```ocl\ncontext Rental::getDiscountedPrice(): Real\n  body: self.price * (1 - self.customer.discount/100.0)\n```\n**Explanation:**\nThis OCL constraint provides the implementation for the `getDiscountedPrice()` operation. It specifies that the returned `Real` value is calculated by taking the rental's base `price` and applying the `discount` associated with the `customer`. Any programming language implementation of this class would now have a formal specification to follow for this method.\n\n\n### Navigating the Model\n\nThe primary power of OCL comes from its ability to navigate through a class diagram, starting from a context instance (`self`) to access its attributes, call its operations, and traverse its associations to reach other objects.\n\n#### Accessing Properties and Traversing Associations\n\nNavigation is performed using the dot (`.`) notation.\n\n* **Accessing Attributes:** `self.age`\n* **Calling Operations:** `self.getAge()` (Note: operations must be query-only and have no side effects).\n* **Traversing an Association:** To navigate, you use the **role name** at the opposite end of the association. If the role is unnamed, you use the name of the class itself, starting with a lowercase letter.\n\n![A diagram showing a Person class associated with a Company class.](images/navigation-person-company.png){width=\"60%\"}\n\n```ocl\ncontext Person inv:\n  -- Navigates from Person to Company via the 'employer' role.\n  -- The result is a single object of type Company.\n  self.employer\n```\n#### Navigation From a Collection\n\nThis is a fundamental concept in OCL. When you start a navigation from an expression that results in a collection, the navigation is performed on **each element** of that collection. The final result is a new collection containing all the individual results.\n\n![A diagram showing navigation from an Administration object to a collection of Person objects.](images/navigation-administration-person.png){width=\"60 %\"}\n\n```ocl\ncontext Administration inv:\n  -- 1. self.persons returns a Set of Person objects: Set{p1, p2}\n  self.persons\n\n  -- 2. Navigating to 'name' from this Set returns a Bag of all names.\n  -- The result is Bag{'jack', 'lisa'}\n  self.persons.name\n\n  -- 3. Navigating to 'age' returns a Bag of all ages.\n  -- The result is Bag{30, 22}\n  self.persons.age\n```\n\n**Note:** When you navigate from a `Set` to an attribute, the result is a `Bag`, not a `Set`, because different objects in the original set could have the same value for that attribute.\n\n#### Chained Navigation\n\nYou can chain navigations together to traverse complex paths in your model. The rules of collection navigation apply at each step.\n\n![A diagram showing chained navigation from Rental to AssignedCar, then CarGroup, then category.](images/navigation-chained-example.png){width=\"60%\"}\n\n```ocl\ncontext Administration inv:\n  -- self.persons -> Set{p1, p2}\n  -- self.persons.children returns a Bag containing all children of p1 and p2.\n  self.persons.children\n\n  -- This expression first gets all children (a Bag),\n  -- then for each child, it navigates to their parents (a Set of 2 Persons).\n  -- The final result is a Bag containing all the parents of all the children.\n  self.persons.children.parent\n  ```\n  \n##### A Note on Flattening Collections\n\nWhen a navigation path involves multiple \"to-many\" associations, OCL automatically simplifies the result.\n\nConsider the expression from the slide:\n```ocl\ncontext Administration inv:\n  self.persons.car\n```\n\nLet's break this down:\n\n1.  `self.persons` returns a `Set` of `Person` objects.\n2.  For each `Person` in that set, `.car` returns a `Set` of `Car` objects (because the multiplicity is `*`).\n3.  The result is therefore a collection of collections, for example: `Bag{ Set{car1}, Set{car2, car3} }`.\n\nInstead of forcing you to work with this complex nested structure, OCL **automatically flattens** it into a single `Bag` containing all the elements: `Bag{car1, car2, car3}`.\n\nThis is why you can continue the navigation chain directly. The expression `self.persons.car.type` works as follows:\n\n1.  `self.persons.car` produces a flattened `Bag` of all cars owned by all persons.\n2.  The navigation `.type` is then applied to each `Car` in this flattened bag.\n3.  The final result is a `Bag` of all the `type` strings from all those cars.\n\n\n### Working with Collections\n\nBecause navigation often results in collections, OCL provides a rich set of predefined operations to query and manipulate them. These operations are always invoked using the arrow (`->`) notation.\n\n#### Basic Operations\n\nThese operations provide fundamental information about a collection or check for the presence of specific elements.\n\n* **`size()`**: Returns the number of elements.\n* **`isEmpty()` / `notEmpty()`**: Checks if the collection is empty or not.\n* **`includes(obj)` / `excludes(obj)`**: Checks if a specific object is in the collection.\n* **`includesAll(coll2)` / `excludesAll(coll2)`**: Checks if all (or no) elements of another collection `coll2` are present.\n* **`count(obj)`**: Counts the occurrences of an object in the collection (most useful for `Bag` and `Sequence`).\n\n*Example: An invariant stating that a Person must have exactly two parents.*\n```ocl\ncontext Person inv:\n  self.parent->size() = 2\n```\n\n#### Iterators: The Power of Collections\nThe most powerful feature of OCL collections is the ability to use **iterators**. An iterator is an operation that evaluates an expression for each element in a collection, allowing you to filter, transform, or verify its properties.\n\n##### `select` and `reject` (Filtering)\nThese are the primary tools for filtering a collection. They return a new collection containing only the elements that satisfy (or don't satisfy) a condition.\n\n* **`select(v | boolean_expression)`**: Returns a sub-collection with elements for which the expression is `true`.\n* **`reject(v | boolean_expression)`**: Returns a sub-collection with elements for which the expression is `false`.\n\n*Example: Select all rentals for a customer that are currently active.*\n```ocl\ncontext Customer\n  def: getActiveRentals(): Set(Rental) =\n    self.rental->select(r | r.state = 'active')\n```\n\n##### `forAll` and `exists` (Quantifiers)\nThese iterators evaluate a condition over a collection and return a single `Boolean` value. They are essential for writing precise invariants.\n\n* **`forAll(v | boolean_expression)`**: Returns `true` if the expression is true for **all** elements.\n* **`exists(v | boolean_expression)`**: Returns `true` if the expression is true for **at least one** element.\n\n*Example: An invariant stating that all cars in a \"Luxury\" car group must be of the brand \"Mercedes\".*\n```ocl\ncontext CarGroup inv:\n  self.category = 'Luxury' implies\n    self.car->forAll(c | c.brand = 'Mercedes')\n```\n\n##### `collect` (Transformation)\nThe `collect` iterator transforms a collection by applying an expression to each of its elements. It returns a new `Bag` containing the results (similar to a `map` function).\n\n*Example: Get a collection of all the registration numbers of the cars rented by a customer.*\n```ocl\ncontext Customer\n  def: allRentedCarRegNums(): Bag(String) =\n    self.rental.assignedCar.car->collect(c | c.regNum)\n```\n\n\n#### `closure` (Transitive Closure)\n\nThe `closure` iterator is an advanced and extremely powerful operation that calculates the **transitive closure** of a relationship over a collection. In simpler terms, it allows you to repeatedly navigate through an association until no more new elements can be discovered.\n\nThis is the perfect tool for working with hierarchical or graph-like structures, such as finding all descendants of a person in a family tree or all sub-parts in an assembly.\n\n**Syntax:** `collection->closure( v | navigation_expression )`\n\n*Example: Find all descendants of a person (their children, their children's children, and so on).*\n\n![A class diagram showing a reflexive 'children' association on the Person class.](images/person-children-example.png){width=\"60%\" fig-align=\"center\"}\n\n```ocl\ncontext Person\n  def: getAllDescendants(): Set(Person) =\n    self.children->closure(p | p.children)\n```\n\n**Explanation:**\n\n1.  `self.children`: The expression starts with the set of the person's direct children.\n2.  `->closure(p | p.children)`: The `closure` iterator then takes each person `p` from that set, finds their own `children`, adds them to the result, and repeats this process until no new descendants can be found. The final result is a flattened `Set` containing all descendants at every level.\n\n### Operations on All Objects (`OclAny`)\n\nBecause `OclAny` is the supertype of all types in your model, the operations it defines are available on **every object**. These are fundamental tools for checking equality, types, and for casting.\n\n#### Equality (`=` and `<>`)\nThese operators check if two expressions refer to the exact same object instance.\n\n* `a = b`: Returns `true` if `a` and `b` are the same object.\n* `a <> b`: Returns `true` if `a` and `b` are different objects.\n\n\n#### Type Checking: `oclIsTypeOf` vs. `oclIsKindOf`\n\nThese two operations are crucial for writing constraints in a generalization hierarchy, but they have a very important semantic difference.\n\n* **`oclIsTypeOf(Type)`**: Returns `true` only if the object is an instance of that **exact** type, and not a subtype.\n* **`oclIsKindOf(Type)`**: Returns `true` if the object is an instance of that type **or any of its subtypes**.\n\nLet's consider the following hierarchy:\n\n![A generalization hierarchy showing Student and Professor inheriting from Person.](images/generalization.png){fig-alt=\"A generalization hierarchy showing Student and Professor inheriting from Person.\" width=\"70%\" fig-align=\"center\"}\n\nThe following examples illustrate the difference:\n\n```ocl\ncontext Person inv:\n  self.oclIsKindOf(Person)   -- returns true\n  self.oclIsTypeOf(Person)   -- returns true\n  self.oclIsKindOf(Student)  -- returns false\n  self.oclIsTypeOf(Student)  -- returns true\n```\n\n```ocl\ncontext Student inv:\n  self.oclIsKindOf(Person)   -- returns true\n  self.oclIsTypeOf(Person)   -- returns false\n  self.oclIsKindOf(Student)  -- returns true\n  self.oclIsTypeOf(Student)  -- returns true\n  self.oclIsKindOf(Professor)-- returns false\n  self.oclIsTypeOf(Professor)-- returns false\n```\n\n#### Type Casting: `oclAsType`\nThis operation allows you to cast an object to a more specific subtype. This is necessary when you need to access attributes or operations that are only defined on that subtype.\n\n* **`oclAsType(Type)`**: Casts the object to the specified `Type`. If the object is not actually of that type or one of its subtypes, the expression result is `invalid`.\n\n*Example: An invariant on a Person object, stating that if that person is a Student, their student ID must not be empty.*\n\n```ocl\ncontext Person inv:\n  self.oclIsKindOf(Student) implies\n    self.oclAsType(Student).studentId->notEmpty()\n```\n**Explanation:** We first check if the `Person` is a `Student` (or a subtype). If so, we cast `self` to `Student` to be able to safely access the `studentId` attribute.\n\n#### Handling Undefined Values (`OclVoid`)\n\nIn OCL, the value `null` has a specific type: **`OclVoid`**. It is used to represent an object that does not exist or an attribute that has not been set.\n\n* **`oclIsUndefined()`**: Returns `true` if the object is `null`.\n* **`oclIsInvalid()`**: Returns `true` if an expression is ill-formed (e.g., navigating from `null`).\n\n*Example: An invariant stating that every `Rental` must be associated with a `Customer` (i.e., the `driver` role cannot be empty).*\n```ocl\ncontext Rental inv:\n  self.driver.oclIsUndefined() = false\n```\nThis is a robust way to check that a mandatory association (1..*) is respected.\n\n---\n\n### Special Operations: `allInstances` and `oclIsNew`\n\nTo conclude our overview of OCL, let's look at two special operations that operate at a meta-level: one that queries all objects of a certain type, and another that checks for an object's creation within a postcondition.\n\n#### `allInstances()`: Accessing All Objects of a Type\n\nThe `allInstances()` operation is unique because it is called directly on a **class**, not on an instance (`self`). It returns a `Set` containing all instances of that specific class that currently exist in the system at the time of evaluation.\n\n**Syntax:** `<ClassName>.allInstances()`\n\nThis operation is extremely powerful for writing global invariants that must hold true across the entire system.\n\n*Example: An invariant to enforce that every employee in the system has a unique employee ID.*\n```ocl\ncontext Employee inv:\n  Employee.allInstances()->forAll(e1, e2 | \n    e1 <> e2 implies e1.employeeId <> e2.employeeId\n  )\n```\n\n::: {.callout-warning icon=\"true\" title=\"Use with Caution\"}\nThe `allInstances()` operation can be computationally expensive and conceptually dangerous. Using it on a type with a potentially huge or even infinite number of instances (like `Integer` or `String`) can lead to problems. It is best reserved for application-specific classes where the number of instances is manageable.\n:::\n\n#### `oclIsNew()`: Checking Object Creation\n\nThe `oclIsNew()` operation is a special tool used **only in postconditions**. It returns `true` if the object on which it is called was created during the execution of the operation specified in the context.\n\n*Example: A postcondition for a `createRental(...)` operation on the `Customer` class, stating that a new `Rental` object has been created and is now linked to the customer.*\n```ocl\ncontext Customer::createRental(...)\n  post: let newRental : Rental = self.rental->select(r | r.oclIsNew())->asSequence()->first() in\n    newRental.oclIsUndefined() = false and newRental.customer = self\n```\n**Explanation:** This advanced postcondition first finds the new `Rental` object created during the operation using `oclIsNew()` and then asserts that this new rental exists and is correctly associated with the current customer (`self`)."},"formats":{"html":{"identifier":{"display-name":"HTML","target-format":"html","base-format":"html"},"execute":{"fig-width":7,"fig-height":5,"fig-format":"retina","fig-dpi":96,"df-print":"default","error":false,"eval":true,"cache":null,"freeze":false,"echo":true,"output":true,"warning":true,"include":true,"keep-md":false,"keep-ipynb":false,"ipynb":null,"enabled":null,"daemon":null,"daemon-restart":false,"debug":false,"ipynb-filters":[],"ipynb-shell-interactivity":null,"plotly-connected":true,"engine":"markdown"},"render":{"keep-tex":false,"keep-typ":false,"keep-source":false,"keep-hidden":false,"prefer-html":false,"output-divs":true,"output-ext":"html","fig-align":"default","fig-pos":null,"fig-env":null,"code-fold":"none","code-overflow":"scroll","code-link":false,"code-line-numbers":false,"code-tools":false,"tbl-colwidths":"auto","merge-includes":true,"inline-includes":false,"preserve-yaml":false,"latex-auto-mk":true,"latex-auto-install":true,"latex-clean":true,"latex-min-runs":1,"latex-max-runs":10,"latex-makeindex":"makeindex","latex-makeindex-opts":[],"latex-tlmgr-opts":[],"latex-input-paths":[],"latex-output-dir":null,"link-external-icon":false,"link-external-newwindow":false,"self-contained-math":false,"format-resources":[],"notebook-links":true},"pandoc":{"standalone":true,"wrap":"none","default-image-extension":"png","to":"html","output-file":"06-ocl.html"},"language":{"toc-title-document":"Table of contents","toc-title-website":"On this page","related-formats-title":"Other Formats","related-notebooks-title":"Notebooks","source-notebooks-prefix":"Source","other-links-title":"Other Links","code-links-title":"Code Links","launch-dev-container-title":"Launch Dev Container","launch-binder-title":"Launch Binder","article-notebook-label":"Article Notebook","notebook-preview-download":"Download Notebook","notebook-preview-download-src":"Download Source","notebook-preview-back":"Back to Article","manuscript-meca-bundle":"MECA Bundle","section-title-abstract":"Abstract","section-title-appendices":"Appendices","section-title-footnotes":"Footnotes","section-title-references":"References","section-title-reuse":"Reuse","section-title-copyright":"Copyright","section-title-citation":"Citation","appendix-attribution-cite-as":"For attribution, please cite this work as:","appendix-attribution-bibtex":"BibTeX citation:","appendix-view-license":"View License","title-block-author-single":"Author","title-block-author-plural":"Authors","title-block-affiliation-single":"Affiliation","title-block-affiliation-plural":"Affiliations","title-block-published":"Published","title-block-modified":"Modified","title-block-keywords":"Keywords","callout-tip-title":"Tip","callout-note-title":"Note","callout-warning-title":"Warning","callout-important-title":"Important","callout-caution-title":"Caution","code-summary":"Code","code-tools-menu-caption":"Code","code-tools-show-all-code":"Show All Code","code-tools-hide-all-code":"Hide All Code","code-tools-view-source":"View Source","code-tools-source-code":"Source Code","tools-share":"Share","tools-download":"Download","code-line":"Line","code-lines":"Lines","copy-button-tooltip":"Copy to Clipboard","copy-button-tooltip-success":"Copied!","repo-action-links-edit":"Edit this page","repo-action-links-source":"View source","repo-action-links-issue":"Report an issue","back-to-top":"Back to top","search-no-results-text":"No results","search-matching-documents-text":"matching documents","search-copy-link-title":"Copy link to search","search-hide-matches-text":"Hide additional matches","search-more-match-text":"more match in this document","search-more-matches-text":"more matches in this document","search-clear-button-title":"Clear","search-text-placeholder":"","search-detached-cancel-button-title":"Cancel","search-submit-button-title":"Submit","search-label":"Search","toggle-section":"Toggle section","toggle-sidebar":"Toggle sidebar navigation","toggle-dark-mode":"Toggle dark mode","toggle-reader-mode":"Toggle reader mode","toggle-navigation":"Toggle navigation","crossref-fig-title":"Figure","crossref-tbl-title":"Table","crossref-lst-title":"Listing","crossref-thm-title":"Theorem","crossref-lem-title":"Lemma","crossref-cor-title":"Corollary","crossref-prp-title":"Proposition","crossref-cnj-title":"Conjecture","crossref-def-title":"Definition","crossref-exm-title":"Example","crossref-exr-title":"Exercise","crossref-ch-prefix":"Chapter","crossref-apx-prefix":"Appendix","crossref-sec-prefix":"Section","crossref-eq-prefix":"Equation","crossref-lof-title":"List of Figures","crossref-lot-title":"List of Tables","crossref-lol-title":"List of Listings","environment-proof-title":"Proof","environment-remark-title":"Remark","environment-solution-title":"Solution","listing-page-order-by":"Order By","listing-page-order-by-default":"Default","listing-page-order-by-date-asc":"Oldest","listing-page-order-by-date-desc":"Newest","listing-page-order-by-number-desc":"High to Low","listing-page-order-by-number-asc":"Low to High","listing-page-field-date":"Date","listing-page-field-title":"Title","listing-page-field-description":"Description","listing-page-field-author":"Author","listing-page-field-filename":"File Name","listing-page-field-filemodified":"Modified","listing-page-field-subtitle":"Subtitle","listing-page-field-readingtime":"Reading Time","listing-page-field-wordcount":"Word Count","listing-page-field-categories":"Categories","listing-page-minutes-compact":"{0} min","listing-page-category-all":"All","listing-page-no-matches":"No matching items","listing-page-words":"{0} words","listing-page-filter":"Filter","draft":"Draft"},"metadata":{"lang":"en","fig-responsive":true,"quarto-version":"1.7.32","bibliography":["references.bib"],"output-dir":"docs","theme":["cosmo","brand"],"title":"The Object Constraint Language (OCL): An Overview"},"extensions":{"book":{"multiFile":true}}},"pdf":{"identifier":{"display-name":"PDF","target-format":"pdf","base-format":"pdf"},"execute":{"fig-width":5.5,"fig-height":3.5,"fig-format":"pdf","fig-dpi":300,"df-print":"default","error":false,"eval":true,"cache":null,"freeze":false,"echo":true,"output":true,"warning":true,"include":true,"keep-md":false,"keep-ipynb":false,"ipynb":null,"enabled":null,"daemon":null,"daemon-restart":false,"debug":false,"ipynb-filters":[],"ipynb-shell-interactivity":null,"plotly-connected":true,"engine":"markdown"},"render":{"keep-tex":false,"keep-typ":false,"keep-source":false,"keep-hidden":false,"prefer-html":false,"output-divs":true,"output-ext":"pdf","fig-align":"default","fig-pos":null,"fig-env":null,"code-fold":"none","code-overflow":"scroll","code-link":false,"code-line-numbers":false,"code-tools":false,"tbl-colwidths":true,"merge-includes":true,"inline-includes":false,"preserve-yaml":false,"latex-auto-mk":true,"latex-auto-install":true,"latex-clean":true,"latex-min-runs":1,"latex-max-runs":10,"latex-makeindex":"makeindex","latex-makeindex-opts":[],"latex-tlmgr-opts":[],"latex-input-paths":[],"latex-output-dir":null,"link-external-icon":false,"link-external-newwindow":false,"self-contained-math":false,"format-resources":[]},"pandoc":{"pdf-engine":"xelatex","standalone":true,"variables":{"graphics":true,"tables":true},"default-image-extension":"pdf","to":"pdf","output-file":"06-ocl.pdf"},"language":{"toc-title-document":"Table of contents","toc-title-website":"On this page","related-formats-title":"Other Formats","related-notebooks-title":"Notebooks","source-notebooks-prefix":"Source","other-links-title":"Other Links","code-links-title":"Code Links","launch-dev-container-title":"Launch Dev Container","launch-binder-title":"Launch Binder","article-notebook-label":"Article Notebook","notebook-preview-download":"Download Notebook","notebook-preview-download-src":"Download Source","notebook-preview-back":"Back to Article","manuscript-meca-bundle":"MECA Bundle","section-title-abstract":"Abstract","section-title-appendices":"Appendices","section-title-footnotes":"Footnotes","section-title-references":"References","section-title-reuse":"Reuse","section-title-copyright":"Copyright","section-title-citation":"Citation","appendix-attribution-cite-as":"For attribution, please cite this work as:","appendix-attribution-bibtex":"BibTeX citation:","appendix-view-license":"View License","title-block-author-single":"Author","title-block-author-plural":"Authors","title-block-affiliation-single":"Affiliation","title-block-affiliation-plural":"Affiliations","title-block-published":"Published","title-block-modified":"Modified","title-block-keywords":"Keywords","callout-tip-title":"Tip","callout-note-title":"Note","callout-warning-title":"Warning","callout-important-title":"Important","callout-caution-title":"Caution","code-summary":"Code","code-tools-menu-caption":"Code","code-tools-show-all-code":"Show All Code","code-tools-hide-all-code":"Hide All Code","code-tools-view-source":"View Source","code-tools-source-code":"Source Code","tools-share":"Share","tools-download":"Download","code-line":"Line","code-lines":"Lines","copy-button-tooltip":"Copy to Clipboard","copy-button-tooltip-success":"Copied!","repo-action-links-edit":"Edit this page","repo-action-links-source":"View source","repo-action-links-issue":"Report an issue","back-to-top":"Back to top","search-no-results-text":"No results","search-matching-documents-text":"matching documents","search-copy-link-title":"Copy link to search","search-hide-matches-text":"Hide additional matches","search-more-match-text":"more match in this document","search-more-matches-text":"more matches in this document","search-clear-button-title":"Clear","search-text-placeholder":"","search-detached-cancel-button-title":"Cancel","search-submit-button-title":"Submit","search-label":"Search","toggle-section":"Toggle section","toggle-sidebar":"Toggle sidebar navigation","toggle-dark-mode":"Toggle dark mode","toggle-reader-mode":"Toggle reader mode","toggle-navigation":"Toggle navigation","crossref-fig-title":"Figure","crossref-tbl-title":"Table","crossref-lst-title":"Listing","crossref-thm-title":"Theorem","crossref-lem-title":"Lemma","crossref-cor-title":"Corollary","crossref-prp-title":"Proposition","crossref-cnj-title":"Conjecture","crossref-def-title":"Definition","crossref-exm-title":"Example","crossref-exr-title":"Exercise","crossref-ch-prefix":"Chapter","crossref-apx-prefix":"Appendix","crossref-sec-prefix":"Section","crossref-eq-prefix":"Equation","crossref-lof-title":"List of Figures","crossref-lot-title":"List of Tables","crossref-lol-title":"List of Listings","environment-proof-title":"Proof","environment-remark-title":"Remark","environment-solution-title":"Solution","listing-page-order-by":"Order By","listing-page-order-by-default":"Default","listing-page-order-by-date-asc":"Oldest","listing-page-order-by-date-desc":"Newest","listing-page-order-by-number-desc":"High to Low","listing-page-order-by-number-asc":"Low to High","listing-page-field-date":"Date","listing-page-field-title":"Title","listing-page-field-description":"Description","listing-page-field-author":"Author","listing-page-field-filename":"File Name","listing-page-field-filemodified":"Modified","listing-page-field-subtitle":"Subtitle","listing-page-field-readingtime":"Reading Time","listing-page-field-wordcount":"Word Count","listing-page-field-categories":"Categories","listing-page-minutes-compact":"{0} min","listing-page-category-all":"All","listing-page-no-matches":"No matching items","listing-page-words":"{0} words","listing-page-filter":"Filter","draft":"Draft"},"metadata":{"block-headings":true,"bibliography":["references.bib"],"output-dir":"docs","documentclass":"scrreprt","title":"The Object Constraint Language (OCL): An Overview"},"extensions":{"book":{"selfContainedOutput":true}}}},"projectFormats":["html","pdf"]}