{"entries":[],"headings":["the-need-for-precision-what-uml-diagrams-dont-say","introduction-to-ocl","language-philosophy","main-applications-of-ocl","fundamental-ocl-concepts","ocl-is-a-typed-language","primitive-types","uml-model-types","collection-types","special-ocl-types","type-conformance-and-subtyping","standard-ocl-operators","logical-operators","the-if-then-else-expression","a-note-on-evaluation","relational-arithmetic-and-string-operators","relational-operators","arithmetic-operators-for-integer-and-real","operators-for-strings-string","operator-precedence","the-context-and-self-keywords","classifier-context","operation-context","attribute-context","writing-constraints-invariants","syntax","invariant-examples","example-1-simple-attribute-constraint","example-2-constraint-across-an-association","example-3-constraint-with-inheritance","writing-contracts-preconditions-and-postconditions","syntax-1","precondition-example","postcondition-example-and-the-pre-keyword","initial-and-derived-values-query-and-body-definitions","init-specifying-initial-values","derive-specifying-derived-values","def-defining-query-operations","body-defining-operation-bodies","navigating-the-model","accessing-properties-and-traversing-associations","navigation-from-a-collection","chained-navigation","a-note-on-flattening-collections","working-with-collections","basic-operations","iterators-the-power-of-collections","select-and-reject-filtering","forall-and-exists-quantifiers","collect-transformation","closure-transitive-closure","operations-on-all-objects-oclany","equality-and","type-checking-oclistypeof-vs.-ocliskindof","type-casting-oclastype","handling-undefined-values-oclvoid","special-operations-allinstances-and-oclisnew","allinstances-accessing-all-objects-of-a-type","oclisnew-checking-object-creation"],"options":{"chapters":true}}