---
title: "The Object Constraint Language (OCL): An Overview"
---

This chapter introduces the **Object Constraint Language (OCL)**, a formal language used to add precise and unambiguous rules to UML models. We will explore why UML diagrams alone are often insufficient and how OCL helps to create more rigorous and verifiable software specifications.

## The Need for Precision: What UML Diagrams Don't Say

As we have seen, UML diagrams, especially Class Diagrams, are powerful tools for modelling the static structure of a system. However, they cannot capture all the business rules and constraints that govern a system's behaviour. A diagram can be syntactically correct but still allow for situations that are logically incorrect or violate business rules.

Consider the following class diagram for a car rental system:

![A class diagram for a car rental system.](images/car-rental-cd.png){fig-alt="Class diagram for a car rental system." width="100%"}

This diagram leaves many important questions unanswered:

* Can a customer who is on the blacklist rent a new car?
* How is the price of a rental calculated?
* Can the pickup and drop-off branches be different?
* Should a driver's license be valid for the entire rental period?

While we could add this information in natural language, this approach is notoriously unreliable. Natural language specifications are prone to what are often called the **"7 Deadly Sins"**:

::: {.callout-warning icon="false" title="The 7 Deadly Sins of Natural Language Specification"}
* **Ambiguity:** A statement can be interpreted in multiple ways.
* **Contradiction:** Two or more rules in the specification conflict with each other.
* **Silence (Incompleteness):** A required rule or feature is not mentioned at all.
* **Noise:** The text contains irrelevant information that obscures the actual requirements.
* **Over-specification:** The text unnecessarily describes implementation details ("how") instead of requirements ("what").
* **Vagueness:** The requirements are not stated precisely enough to be verified.
* **Wishful Thinking:** A requirement is described that is impossible to implement.
:::

These issues make automated verification impossible and lead to costly errors in implementation. To solve this, we need a formal, unambiguous way to express these rules, which is precisely the role of OCL.


## Introduction to OCL

To solve the problems of ambiguity and imprecision, the **Object Constraint Language (OCL)** was created. It is the official standard from the OMG (Object Management Group) for adding formal constraints to UML models.

OCL is a **declarative, textual, and formal language**. This means:

* **Declarative:** You specify *what* should be true, not *how* to check it.
* **Textual:** It integrates seamlessly with the graphical nature of UML diagrams.
* **Formal:** It has a well-defined mathematical foundation, which removes ambiguity.

It is designed to be a middle ground: more precise than natural language, but less complex and easier to learn than purely mathematical formalisms.

### Language Philosophy

To use OCL correctly, it is crucial to understand its core philosophy: OCL is a **pure specification language**, not a programming language. This has two major consequences:

::: {.callout-note icon="true" title="No Side Effects"}
An OCL expression is a query that can only **read** the state of the model, it can **never change it**. You cannot use OCL to assign a value to an attribute, create an object, or call an operation that modifies the system's state. This guarantees that checking a constraint will never alter the system you are verifying.
:::

::: {.callout-note icon="true" title="Instantaneous Evaluation"}
The evaluation of an OCL expression is considered to be **instantaneous**. This is a powerful abstraction that means the state of the system is "frozen" during the evaluation of a constraint. You don't have to worry about other parts of the system changing while your expression is being checked, which greatly simplifies writing complex rules.
:::

## Main Applications of OCL

OCL is a versatile language used to add precision to a model in several key ways. Let's explore its main applications with concrete examples based on our car rental system.

1.  **Constraining Models (Invariants):**
    The primary use of OCL is to write **invariants**. An invariant is a rule that must be true for all instances of a class at all times.

    *Example: A customer's discount must always be a positive value.*
    ```ocl
    context Customer inv:
      self.discount >= 0
    ```
    **Explanation:** This simple invariant ensures that for any `Customer` object, the `discount` attribute (which is an `Integer` in the diagram) can never be negative.

2.  **Specifying Contracts (Preconditions & Postconditions):**
    OCL is used to define formal contracts for operations. A **precondition** must be true *before* an operation is executed, and a **postcondition** must be true *after*.

    *Example: To extend a rental, its state must be 'active'.*
    ```ocl
    context Rental::extendRental(newDate: Date)
      pre must_be_active:
        self.state = 'active'
    ```
    **Explanation:** This precondition checks that the `state` attribute of the `Rental` instance is equal to the string `'active'`. The operation cannot be called otherwise.

3.  **Specifying Derived Values:**
    OCL can define how the value of an attribute should be calculated from other information. This is for values that are not stored directly.

    *Example: Let's define a derived boolean attribute `isPrivileged` for a `Customer`.*
    ```ocl
    context Customer derive: isPrivileged: Boolean =
      self.premium = true and self.discount > 10
    ```
    **Explanation:** This rule states that a customer is considered "privileged" if and only if their `premium` status is true and their `discount` is greater than 10.

4.  **Defining Queries:**
    You can use OCL to navigate through the model to retrieve information, much like a query.

    *Example: A query to get the set of all active rentals for a specific customer.*
    ```ocl
    context Customer
      def: getActiveRentals(): Set(Rental) =
        self.rental->select(r | r.state = 'active')
    ```
    **Explanation:** This defines a new operation `getActiveRentals` on the `Customer` class. It navigates to the customer's collection of `rental` and uses the `select` iterator to return a new set containing only those rentals whose `state` is 'active'.


## Fundamental OCL Concepts

To write meaningful constraints, we first need to understand the two pillars of the OCL language: its **robust typing system**, and its **precise syntax and the formal semantics** that underpin it.



### OCL is a Typed Language

Every element in OCL, from an attribute to the result of a complex navigation, has a **type**. This strong typing system ensures that expressions are well-formed and prevents errors, much like in languages like Java. OCL's type system is built from three sources:

#### Primitive Types
OCL includes four fundamental, built-in types that are the basis for most expressions:

* `Integer` (e.g., `5`, `-10`)
* `Real` (e.g., `3.14`, `-0.5`)
* `String` (e.g., `'active'`, `'John Doe'`)
* `Boolean` (`true`, `false`)

#### UML Model Types
This is a powerful feature: **every classifier you define in your UML model automatically becomes a new type in OCL**. If you have a class named `Customer` in your diagram, `Customer` becomes a valid type in your OCL expressions. This allows you to write constraints that are perfectly tailored to your specific domain.

#### Collection Types
Because navigating associations often results in multiple objects, OCL has a rich set of built-in collection types to handle them. The collection is an abstract type with four concrete subtypes:

| Collection Type | Order Matters? | Duplicates Allowed? | Example Literal |
| :--- | :--- | :--- | :--- |
| **`Set(T)`** | No | No | `Set{1, 2, 3}` |
| **`OrderedSet(T)`**| Yes | No | `OrderedSet{1, 2, 3}`|
| **`Bag(T)`** | No | Yes | `Bag{1, 2, 2, 3}` |
| **`Sequence(T)`**| Yes | Yes | `Sequence{1, 3, 2, 3}`|

By default, navigating a `*` multiplicity association returns a `Set`. Understanding these collection types is essential, as most non-trivial OCL expressions involve manipulating collections.

### Special OCL Types

Beyond the primitive and model-based types, OCL provides a set of special, built-in classifiers that are essential for writing advanced constraints. The hierarchy of these types is shown in the diagram below.

![A class diagram showing the OCL Type Hierarchy, with Classifier at the top.](images/ocl-type-hierarchy.png){fig-alt="The OCL Type Hierarchy" width="100%"}


Let's explore the most important ones:

* **`OclAny`**: This is the supertype of all other types in OCL (except for collection and tuple types). Any operation defined on `OclAny` (like `oclIsTypeOf()`) is available on all objects in your model.

* **`OclVoid`**: This type has only one possible value: `null`. It is used to check if a property has been set or not. Any expression that results in a division by zero, for example, will evaluate to `null`. You can check for this value using the `oclIsUndefined()` operation.

* **`OclInvalid`**: This type has only one value: `invalid`. It is used to represent the result of an ill-formed expression, for instance, when trying to navigate from `null`. It is a subtype of all other types, meaning an `invalid` value can "poison" an entire expression. You can check for it with `oclIsInvalid()`.

* **`TupleType`**: A tuple is a structured type that groups together several named parts, each with its own type. It's similar to a struct or a record and is very useful for returning multiple values from a query operation.

    ```ocl
    Tuple{name: String = 'Mikel', id: Integer = 123}
    ```

* **`OclState`**: This special type is used exclusively within state machine diagrams. The operation `oclIsInState(stateName: OclState)` allows you to write a constraint that checks if an object is currently in a specific state, which is very powerful for defining state-dependent invariants.

* **`OclMessage`**: Used in interaction diagrams (like sequence diagrams), this type allows you to write constraints on the messages exchanged between objects. For example, you can check if a specific message has been sent or received.


### Type Conformance and Subtyping

The OCL type system is not flat, it has a rich hierarchy that defines which types are considered subtypes of others. This is known as **type conformance**. Understanding these rules is crucial, as it determines when a value of one type can be used where a value of another type is expected.

The main rules of type conformance in OCL are as follows:

1.  For primitive numbers, the hierarchy is logical: `UnlimitedNatural` is a subtype of `Integer`, which is a subtype of `Real`.
2.  `OclAny` is the ultimate supertype for all non-collection types. This means any object from your UML model is conformant to `OclAny`.
3.  The hierarchy of your **UML model types** mirrors the generalization (inheritance) relationships in your class diagram. If you have a `Student` class that inherits from `Person`, then `Student` is a subtype of `Person` in OCL.
4.  For collections, `Set(T)`, `Bag(T)`, `Sequence(T)`, and `OrderedSet(T)` are all subtypes of the general `Collection(T)` type.
5.  The special types have their own rules:
    * `OclVoid` (representing `null`) is a subtype of all other types (except `OclInvalid`).
    * `OclInvalid` is the ultimate subtype, it is a subtype of *every other type*. This explains why an `invalid` value can propagate through and "poison" any expression.

This hierarchy is visualized in the diagram below.

![A class diagram showing the OCL Type Hierarchy and a list of the 7 conformance rules.](images/type-conformance-rules.png){fig-alt="The OCL Type Hierarchy and its conformance rules." width="30%"}

### Standard OCL Operators

Like any language, OCL comes with a standard set of operators to perform logical, relational, and arithmetic operations. These are the building blocks for creating complex boolean expressions within your constraints.

#### Logical Operators
OCL supports the standard boolean logic operators. Note that they are written in lowercase.

| Operator | Syntax | Description |
| :--- | :--- | :--- |
| **and** | `a and b` | True if both `a` and `b` are true. |
| **or** | `a or b` | True if either `a` or `b` is true. |
| **xor** | `a xor b` | True if exactly one of `a` or `b` is true. |
| **not** | `not a` | True if `a` is false. |
| **implies**| `a implies b`| False only if `a` is true and `b` is false. |

*Example: A premium customer must have a discount.*
```ocl
context Customer inv:
  self.premium implies (self.discount > 0)
```

##### The `if-then-else` Expression
Unlike in many programming languages, `if` in OCL is not a statement but an **expression** that always returns a value.

```ocl
context Customer
  def: customerCategory: String =
    if self.premium then
      'High Value'
    else
      'Standard'
    endif
```

::: {.callout-warning icon="true" title="Important Rules for `if` expressions"}
* **The `else` clause is mandatory.** Since `if` is an expression, it must always result in a value, so the `else` part can never be omitted.
* **Type Conformance.** The type of the `if` expression is the most specific common supertype of the `then` expression and the `else` expression.
:::

##### A Note on Evaluation
OCL has a very specific rule for evaluating boolean expressions that differs from many common programming languages.

::: {.callout-warning icon="true" title="No Short-Circuit Evaluation"}
The logical operators `and`, `or`, and `xor` in OCL are **strict**. This means that **both operands are always evaluated**, even if the result of the first operand is enough to determine the outcome. There is no "short-circuit" or "lazy" evaluation. This is a common source of errors, especially when dealing with potentially null values.
:::

#### Relational, Arithmetic, and String Operators
OCL provides a rich set of standard operators for the primitive types, allowing for the construction of detailed and precise expressions.

##### Relational Operators
These operators are used for comparison and work across most primitive types to produce a `Boolean` result.

| Operator | Description |
| :--- | :--- |
| **`=`** | Equality |
| **`<>`** | Inequality (not equal) |
| **`<`** | Less than |
| **`>`** | Greater than |
| **`<=`** | Less than or equal to |
| **`>=`** | Greater than or equal to |

##### Arithmetic Operators for (`Integer` and `Real`)
OCL provides a standard library of arithmetic functions for numerical types.

| Operator | Description |
| :--- | :--- |
| **`+`, `-`, `*`, `/`** | Addition, Subtraction, Multiplication, Division |
| **`abs()`** | Absolute value |
| **`floor()`**, **`round()`** | Floor and Rounding functions |
| **`max(n)`**, **`min(n)`** | The maximum or minimum of two numbers |
| **`mod(n)`** | Modulo operation |

##### Operators for Strings (`String`)
OCL includes a powerful set of operations for manipulating strings.

| Operation | Description | Example |
| :--- | :--- | :--- |
| **`size()`** | Returns the number of characters in the string. | `'hello'.size() = 5` |
| **`concat(s2)`**| Concatenates another string `s2`. | `'hello'.concat(' world')` results in `'hello world'` |
| **`toUpper()`** | Converts the string to uppercase. | `'hello'.toUpper()` results in `'HELLO'` |
| **`toLower()`** | Converts the string to lowercase. | `'HELLO'.toLower()` results in `'hello'` |
| **`substring(i1, i2)`** | Returns the substring from index `i1` to `i2`. | `'hello'.substring(2, 4)` results in `'ell'` |

*Example: An invariant stating that a car group's category must be a single uppercase letter.*
```ocl
context CarGroup inv:
  self.category.size() = 1 and self.category = self.category.toUpper()
```

#### Operator Precedence

OCL defines a strict order of precedence to determine how complex expressions are evaluated. The following table lists the operators in decreasing order of priority, from highest (evaluated first) to lowest (evaluated last).

| Priority | Operator(s) | Description |
| :--- | :--- | :--- |
| **1** (Highest) | `@pre` | Time marker (used in post-conditions) |
| **2** | `.` , `->` | Navigation (dot and arrow) |
| **3** | `not` , `-` | Unary operators (negation) |
| **4** | `*` , `/` | Multiplication, Division |
| **5** | `+` , `-` | Addition, Subtraction (binary) |
| **6** | `if-then-else-endif`| Conditional expression |
| **7** | `=` , `<>` , `>` , `<` , `>=` , `<=` | Relational operators |
| **8** | `and` , `or` , `xor` | Logical operators |
| **9** | `implies` | Logical implication |
| **10** (Lowest)| `in` | (Not covered yet) |

::: {.callout-tip icon="true" title="Best Practice: Use Parentheses"}
Even if you know the precedence rules, it is always a good practice to use parentheses `()` to make your expressions explicit and easier to read. This avoids any ambiguity for you and for others who will read your model.
:::

### The `context` and `self` Keywords

Every OCL constraint is anchored to a specific element in the UML model. The **`context`** keyword declares this anchor, defining the perspective from which the OCL expression will be evaluated. Within this context, the keyword **`self`** always refers to the specific instance of the element being constrained.

OCL defines three primary types of context:

#### Classifier Context

This is the most common context, used for defining **invariants**. The context is a classifier, typically a class, and `self` refers to an instance of that class.

**Syntax:** `context <ClassName>`
```ocl
context Customer inv:
  self.discount >= 0
```

#### Operation Context

This context is used to define **preconditions** and **postconditions** for an operation. The context is a specific operation within a class, and `self` refers to the instance of the class on which the operation is being called.

**Syntax:** `context <ClassName>::<operationName>(...)`
```ocl
context Rental::extendRental(newDate: Date)
  pre: self.state = 'active'
```

#### 3. Attribute Context

This context is used to define constraints on an attribute, typically for **derived values** or **initial values**. The context is a specific attribute within a class, and `self` refers to the instance of the class that owns the attribute.

**Syntax:** `context <ClassName>::<attributeName>: <Type>`
```ocl
context Customer::isPrivileged: Boolean
  derive: self.premium = true and self.discount > 10
```

### Writing Constraints: Invariants

The most common type of constraint you will write in OCL is the **invariant**.

::: {.callout-note icon="true" title="What is an Invariant?"}
An invariant is a constraint that must be **true** for all instances of a class at **all times** during the system's execution. It defines a condition of integrity that can never be violated. If an operation causes an invariant to become false, the system is considered to be in an invalid state.
:::

#### Syntax

The general syntax for an invariant is straightforward:

**`context`** `<Classifier>` **`inv`** `[`<constraint_name>`]:`
  `<boolean_expression>`

* **`context <Classifier>`**: Specifies the class to which the invariant applies.
* **`inv`**: The stereotype indicating this is an invariant.
* **`[<constraint_name>]`**: An optional but highly recommended name for the constraint.
* **`<boolean_expression>`**: The OCL expression that must always evaluate to `true`.


#### Invariant Examples

Let's illustrate with a few examples based on our car rental system.

##### Example 1: Simple Attribute Constraint

A very common use for invariants is to restrict the possible values of an attribute.

* **Rule:** A customer's discount must be a positive value.
```ocl
context Customer inv:
  self.discount >= 0
```

##### Example 2: Constraint Across an Association
Invariants are powerful for defining rules that involve multiple, associated classes.

* **Rule:** A car that is currently assigned to an active rental cannot be part of a `CarGroup` marked as 'in_maintenance'.
```ocl
context Car inv:
  self.rental->exists(r | r.state = 'active') implies 
    self.carGroup.category <> 'in_maintenance'
```
##### Example 3: Constraint with Inheritance
Invariants can also enforce rules related to a class hierarchy.

* **Rule:** A customer who is on the blacklist (i.e., is of type `BlackListed`) cannot have any active rentals.
```ocl
context Customer inv:
  self.oclIsTypeOf(BlackListed) implies
    self.rental->select(r | r.state = 'active')->isEmpty()
```

### Writing Contracts: Preconditions and Postconditions

While invariants define the rules for a class's state, **preconditions** and **postconditions** define a **contract** for its operations. They specify what an operation requires to run and what it guarantees to accomplish.

::: {.callout-note icon="true" title="What are Preconditions and Postconditions?"}
* A **precondition** is a constraint that must be `true` **before** an operation is executed. It is the responsibility of the *caller* to satisfy the precondition. If it's false, the operation should not be called.
* A **postcondition** is a constraint that must be `true` **after** an operation has successfully completed. It is the responsibility of the *operation itself* to establish the postcondition.
:::

#### Syntax

The syntax is similar to invariants, but the context is an operation, and the stereotypes are `pre` and `post`.

**`context`** `<Classifier>::<operationName>(...)`
  **`pre`** `[`<constraint_name>`]:` `<boolean_expression>`
  **`post`** `[`<constraint_name>`]:` `<boolean_expression>`


##### Precondition Example

A precondition specifies the conditions under which an operation can be legally called.

* **Rule:** A customer can only be added to the blacklist if they are not already on it.
```ocl
context Customer::addToBlackList(d: Date)
  pre is_not_already_blacklisted:
    self.oclIsTypeOf(BlackListed) = false
```

**Explanation:** This contract states that before calling `addToBlackList` on a `Customer` object, that object must not already be of the type `BlackListed`.



##### Postcondition Example and the `@pre` Keyword

A postcondition specifies the state of the system after the operation has finished. A crucial tool for this is the `@pre` keyword, which allows you to refer to a value as it was *before* the operation started.

* **Rule:** After a customer is successfully added to the blacklist, they must be of the type `BlackListed`.

```ocl
context Customer::addToBlackList(d: Date)
  post is_now_blacklisted:
    self.oclIsTypeOf(BlackListed) = true
```
Here's a more complex example using `@pre`:

* **Rule:** After a rental is extended, the new end date must be the one provided, and the number of associated cars must not have changed.
```ocl
context Rental::extendRental(newDate: Date)
  post end_date_is_updated:
    self.endingDate = newDate
  post number_of_cars_is_unchanged:
    self.assignedCar->size() = self.assignedCar@pre->size()
```
**Explanation:**

* The first postcondition checks the new value of `endingDate`.
* The second postcondition is critical: it uses `self.assignedCar@pre` to refer to the collection of cars *before* the operation ran and ensures its size has not changed. This prevents unintended side effects.


### Initial and Derived Values, Query and Body Definitions

Beyond invariants and contracts, OCL can be used to precisely define how attributes and operations get their values.

#### `init`: Specifying Initial Values

The **`init`** stereotype allows you to define a constraint for the initial value of an attribute when an object is created. This is more powerful than a simple default value because you can use a complex OCL expression.

**Syntax:** `context <ClassName>::<attributeName>: <Type> init: <expression>`

*Example: When a `Rental` object is created, its `state` is initialized to 'planned'.*
```ocl
context Rental::state: String
  init: 'planned'
```
#### `derive`: Specifying Derived Values

The **`derive`** stereotype is used for attributes whose value is not stored but is always calculated based on other properties of the model. This is used for derived attributes, which are often denoted with a `/` in front of their name in a class diagram.

**Syntax:** `context <ClassName>::<attributeName>: <Type> derive: <expression>`

*Example: A customer is considered "privileged" if they are premium and have a discount greater than 10.*
```ocl
context Customer::isPrivileged: Boolean
  derive: self.premium = true and self.discount > 10
```

#### `def`: Defining Query Operations

The **`def`** stereotype allows you to define the body of a query operation directly in OCL. This is useful for specifying operations that retrieve information without changing the system's state.

**Syntax:** `context <ClassName> def: <operationName>(): <ReturnType> = <expression>`

*Example: Defining an operation that returns the set of all active rentals for a customer.*
```ocl
context Customer
  def: getActiveRentals(): Set(Rental) =
    self.rental->select(r | r.state = 'active')
```

#### `body`: Defining Operation Bodies

While `def` is used to define a new query operation not present in the UML model, the **`body`** stereotype is used to provide a **concrete implementation** for an operation that is already **declared** in a class diagram.

This is particularly useful when you want to formally specify the result of a query operation without leaving its logic ambiguous.

**Syntax:** `context <ClassName>::<operationName>(): <ReturnType> body: <expression>`

*Example: Defining the body for a `getDiscountedPrice()` operation on the `Rental` class.*
```ocl
context Rental::getDiscountedPrice(): Real
  body: self.price * (1 - self.customer.discount/100.0)
```
**Explanation:**
This OCL constraint provides the implementation for the `getDiscountedPrice()` operation. It specifies that the returned `Real` value is calculated by taking the rental's base `price` and applying the `discount` associated with the `customer`. Any programming language implementation of this class would now have a formal specification to follow for this method.


### Navigating the Model

The primary power of OCL comes from its ability to navigate through a class diagram, starting from a context instance (`self`) to access its attributes, call its operations, and traverse its associations to reach other objects.

#### Accessing Properties and Traversing Associations

Navigation is performed using the dot (`.`) notation.

* **Accessing Attributes:** `self.age`
* **Calling Operations:** `self.getAge()` (Note: operations must be query-only and have no side effects).
* **Traversing an Association:** To navigate, you use the **role name** at the opposite end of the association. If the role is unnamed, you use the name of the class itself, starting with a lowercase letter.

![A diagram showing a Person class associated with a Company class.](images/navigation-person-company.png){width="60%"}

```ocl
context Person inv:
  -- Navigates from Person to Company via the 'employer' role.
  -- The result is a single object of type Company.
  self.employer
```
#### Navigation From a Collection

This is a fundamental concept in OCL. When you start a navigation from an expression that results in a collection, the navigation is performed on **each element** of that collection. The final result is a new collection containing all the individual results.

![A diagram showing navigation from an Administration object to a collection of Person objects.](images/navigation-administration-person.png){width="60 %"}

```ocl
context Administration inv:
  -- 1. self.persons returns a Set of Person objects: Set{p1, p2}
  self.persons

  -- 2. Navigating to 'name' from this Set returns a Bag of all names.
  -- The result is Bag{'jack', 'lisa'}
  self.persons.name

  -- 3. Navigating to 'age' returns a Bag of all ages.
  -- The result is Bag{30, 22}
  self.persons.age
```

**Note:** When you navigate from a `Set` to an attribute, the result is a `Bag`, not a `Set`, because different objects in the original set could have the same value for that attribute.

#### Chained Navigation

You can chain navigations together to traverse complex paths in your model. The rules of collection navigation apply at each step.

![A diagram showing chained navigation from Rental to AssignedCar, then CarGroup, then category.](images/navigation-chained-example.png){width="60%"}

```ocl
context Administration inv:
  -- self.persons -> Set{p1, p2}
  -- self.persons.children returns a Bag containing all children of p1 and p2.
  self.persons.children

  -- This expression first gets all children (a Bag),
  -- then for each child, it navigates to their parents (a Set of 2 Persons).
  -- The final result is a Bag containing all the parents of all the children.
  self.persons.children.parent
  ```
  
##### A Note on Flattening Collections

When a navigation path involves multiple "to-many" associations, OCL automatically simplifies the result.

Consider the expression from the slide:
```ocl
context Administration inv:
  self.persons.car
```

Let's break this down:

1.  `self.persons` returns a `Set` of `Person` objects.
2.  For each `Person` in that set, `.car` returns a `Set` of `Car` objects (because the multiplicity is `*`).
3.  The result is therefore a collection of collections, for example: `Bag{ Set{car1}, Set{car2, car3} }`.

Instead of forcing you to work with this complex nested structure, OCL **automatically flattens** it into a single `Bag` containing all the elements: `Bag{car1, car2, car3}`.

This is why you can continue the navigation chain directly. The expression `self.persons.car.type` works as follows:

1.  `self.persons.car` produces a flattened `Bag` of all cars owned by all persons.
2.  The navigation `.type` is then applied to each `Car` in this flattened bag.
3.  The final result is a `Bag` of all the `type` strings from all those cars.


### Working with Collections

Because navigation often results in collections, OCL provides a rich set of predefined operations to query and manipulate them. These operations are always invoked using the arrow (`->`) notation.

#### Basic Operations

These operations provide fundamental information about a collection or check for the presence of specific elements.

* **`size()`**: Returns the number of elements.
* **`isEmpty()` / `notEmpty()`**: Checks if the collection is empty or not.
* **`includes(obj)` / `excludes(obj)`**: Checks if a specific object is in the collection.
* **`includesAll(coll2)` / `excludesAll(coll2)`**: Checks if all (or no) elements of another collection `coll2` are present.
* **`count(obj)`**: Counts the occurrences of an object in the collection (most useful for `Bag` and `Sequence`).

*Example: An invariant stating that a Person must have exactly two parents.*
```ocl
context Person inv:
  self.parent->size() = 2
```

#### Iterators: The Power of Collections
The most powerful feature of OCL collections is the ability to use **iterators**. An iterator is an operation that evaluates an expression for each element in a collection, allowing you to filter, transform, or verify its properties.

##### `select` and `reject` (Filtering)
These are the primary tools for filtering a collection. They return a new collection containing only the elements that satisfy (or don't satisfy) a condition.

* **`select(v | boolean_expression)`**: Returns a sub-collection with elements for which the expression is `true`.
* **`reject(v | boolean_expression)`**: Returns a sub-collection with elements for which the expression is `false`.

*Example: Select all rentals for a customer that are currently active.*
```ocl
context Customer
  def: getActiveRentals(): Set(Rental) =
    self.rental->select(r | r.state = 'active')
```

##### `forAll` and `exists` (Quantifiers)
These iterators evaluate a condition over a collection and return a single `Boolean` value. They are essential for writing precise invariants.

* **`forAll(v | boolean_expression)`**: Returns `true` if the expression is true for **all** elements.
* **`exists(v | boolean_expression)`**: Returns `true` if the expression is true for **at least one** element.

*Example: An invariant stating that all cars in a "Luxury" car group must be of the brand "Mercedes".*
```ocl
context CarGroup inv:
  self.category = 'Luxury' implies
    self.car->forAll(c | c.brand = 'Mercedes')
```

##### `collect` (Transformation)
The `collect` iterator transforms a collection by applying an expression to each of its elements. It returns a new `Bag` containing the results (similar to a `map` function).

*Example: Get a collection of all the registration numbers of the cars rented by a customer.*
```ocl
context Customer
  def: allRentedCarRegNums(): Bag(String) =
    self.rental.assignedCar.car->collect(c | c.regNum)
```


#### `closure` (Transitive Closure)

The `closure` iterator is an advanced and extremely powerful operation that calculates the **transitive closure** of a relationship over a collection. In simpler terms, it allows you to repeatedly navigate through an association until no more new elements can be discovered.

This is the perfect tool for working with hierarchical or graph-like structures, such as finding all descendants of a person in a family tree or all sub-parts in an assembly.

**Syntax:** `collection->closure( v | navigation_expression )`

*Example: Find all descendants of a person (their children, their children's children, and so on).*

![A class diagram showing a reflexive 'children' association on the Person class.](images/person-children-example.png){width="60%" fig-align="center"}

```ocl
context Person
  def: getAllDescendants(): Set(Person) =
    self.children->closure(p | p.children)
```

**Explanation:**

1.  `self.children`: The expression starts with the set of the person's direct children.
2.  `->closure(p | p.children)`: The `closure` iterator then takes each person `p` from that set, finds their own `children`, adds them to the result, and repeats this process until no new descendants can be found. The final result is a flattened `Set` containing all descendants at every level.

### Operations on All Objects (`OclAny`)

Because `OclAny` is the supertype of all types in your model, the operations it defines are available on **every object**. These are fundamental tools for checking equality, types, and for casting.

#### Equality (`=` and `<>`)
These operators check if two expressions refer to the exact same object instance.

* `a = b`: Returns `true` if `a` and `b` are the same object.
* `a <> b`: Returns `true` if `a` and `b` are different objects.


#### Type Checking: `oclIsTypeOf` vs. `oclIsKindOf`

These two operations are crucial for writing constraints in a generalization hierarchy, but they have a very important semantic difference.

* **`oclIsTypeOf(Type)`**: Returns `true` only if the object is an instance of that **exact** type, and not a subtype.
* **`oclIsKindOf(Type)`**: Returns `true` if the object is an instance of that type **or any of its subtypes**.

Let's consider the following hierarchy:

![A generalization hierarchy showing Student and Professor inheriting from Person.](images/generalization.png){fig-alt="A generalization hierarchy showing Student and Professor inheriting from Person." width="70%" fig-align="center"}

The following examples illustrate the difference:

```ocl
context Person inv:
  self.oclIsKindOf(Person)   -- returns true
  self.oclIsTypeOf(Person)   -- returns true
  self.oclIsKindOf(Student)  -- returns false
  self.oclIsTypeOf(Student)  -- returns true
```

```ocl
context Student inv:
  self.oclIsKindOf(Person)   -- returns true
  self.oclIsTypeOf(Person)   -- returns false
  self.oclIsKindOf(Student)  -- returns true
  self.oclIsTypeOf(Student)  -- returns true
  self.oclIsKindOf(Professor)-- returns false
  self.oclIsTypeOf(Professor)-- returns false
```

#### Type Casting: `oclAsType`
This operation allows you to cast an object to a more specific subtype. This is necessary when you need to access attributes or operations that are only defined on that subtype.

* **`oclAsType(Type)`**: Casts the object to the specified `Type`. If the object is not actually of that type or one of its subtypes, the expression result is `invalid`.

*Example: An invariant on a Person object, stating that if that person is a Student, their student ID must not be empty.*

```ocl
context Person inv:
  self.oclIsKindOf(Student) implies
    self.oclAsType(Student).studentId->notEmpty()
```
**Explanation:** We first check if the `Person` is a `Student` (or a subtype). If so, we cast `self` to `Student` to be able to safely access the `studentId` attribute.

#### Handling Undefined Values (`OclVoid`)

In OCL, the value `null` has a specific type: **`OclVoid`**. It is used to represent an object that does not exist or an attribute that has not been set.

* **`oclIsUndefined()`**: Returns `true` if the object is `null`.
* **`oclIsInvalid()`**: Returns `true` if an expression is ill-formed (e.g., navigating from `null`).

*Example: An invariant stating that every `Rental` must be associated with a `Customer` (i.e., the `driver` role cannot be empty).*
```ocl
context Rental inv:
  self.driver.oclIsUndefined() = false
```
This is a robust way to check that a mandatory association (1..*) is respected.

---

### Special Operations: `allInstances` and `oclIsNew`

To conclude our overview of OCL, let's look at two special operations that operate at a meta-level: one that queries all objects of a certain type, and another that checks for an object's creation within a postcondition.

#### `allInstances()`: Accessing All Objects of a Type

The `allInstances()` operation is unique because it is called directly on a **class**, not on an instance (`self`). It returns a `Set` containing all instances of that specific class that currently exist in the system at the time of evaluation.

**Syntax:** `<ClassName>.allInstances()`

This operation is extremely powerful for writing global invariants that must hold true across the entire system.

*Example: An invariant to enforce that every employee in the system has a unique employee ID.*
```ocl
context Employee inv:
  Employee.allInstances()->forAll(e1, e2 | 
    e1 <> e2 implies e1.employeeId <> e2.employeeId
  )
```

::: {.callout-warning icon="true" title="Use with Caution"}
The `allInstances()` operation can be computationally expensive and conceptually dangerous. Using it on a type with a potentially huge or even infinite number of instances (like `Integer` or `String`) can lead to problems. It is best reserved for application-specific classes where the number of instances is manageable.
:::

#### `oclIsNew()`: Checking Object Creation

The `oclIsNew()` operation is a special tool used **only in postconditions**. It returns `true` if the object on which it is called was created during the execution of the operation specified in the context.

*Example: A postcondition for a `createRental(...)` operation on the `Customer` class, stating that a new `Rental` object has been created and is now linked to the customer.*
```ocl
context Customer::createRental(...)
  post: let newRental : Rental = self.rental->select(r | r.oclIsNew())->asSequence()->first() in
    newRental.oclIsUndefined() = false and newRental.customer = self
```
**Explanation:** This advanced postcondition first finds the new `Rental` object created during the operation using `oclIsNew()` and then asserts that this new rental exists and is correctly associated with the current customer (`self`).