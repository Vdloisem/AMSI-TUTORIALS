[
  {
    "objectID": "index.html",
    "href": "index.html",
    "title": "AMSI-TUTORIALS",
    "section": "",
    "text": "Preface\nThis is a Quarto book.\nTo learn more about Quarto books visit https://quarto.org/docs/books.",
    "crumbs": [
      "Preface"
    ]
  },
  {
    "objectID": "intro.html",
    "href": "intro.html",
    "title": "1  Introduction",
    "section": "",
    "text": "This is a book created from markdown and executable code.\nSee Knuth (1984) for additional discussion of literate programming.\n\n\n\n\nKnuth, Donald E. 1984. “Literate Programming.” Comput. J. 27 (2): 97–111. https://doi.org/10.1093/comjnl/27.2.97.",
    "crumbs": [
      "<span class='chapter-number'>1</span>  <span class='chapter-title'>Introduction</span>"
    ]
  },
  {
    "objectID": "summary.html",
    "href": "summary.html",
    "title": "10  Summary",
    "section": "",
    "text": "In summary, this book has no content whatsoever.",
    "crumbs": [
      "<span class='chapter-number'>10</span>  <span class='chapter-title'>Summary</span>"
    ]
  },
  {
    "objectID": "references.html",
    "href": "references.html",
    "title": "References",
    "section": "",
    "text": "Knuth, Donald E. 1984. “Literate Programming.” Comput.\nJ. 27 (2): 97–111. https://doi.org/10.1093/comjnl/27.2.97.",
    "crumbs": [
      "References"
    ]
  },
  {
    "objectID": "01-intro-modelling.html",
    "href": "01-intro-modelling.html",
    "title": "1  Introduction to Modelling",
    "section": "",
    "text": "1.0.1 The Central Challenge: Managing Complexity\nThis chapter introduces the principles of modelling in the context of information systems engineering. By the end of this section, you will be able to define what a model is, identify the qualities of a good model, and understand why modelling is an indispensable activity in modern software engineering.\nAs software systems become increasingly complex, the primary challenge for engineers is not just writing code, but managing the immense complexity of the systems they build. How do we ensure that a large-scale system is correct, robust, and aligned with user needs before investing thousands of hours in implementation? This is the core problem that modelling addresses.\nThe following quotes highlight the human-centric and real-world implications of this challenge:\nThese reflections guide our approach: modelling is not an abstract exercise but a critical tool for building systems that are both technically sound and meaningful in the real world.",
    "crumbs": [
      "<span class='chapter-number'>1</span>  <span class='chapter-title'>Introduction to Modelling</span>"
    ]
  },
  {
    "objectID": "01-intro-modelling.html#models-in-engineering",
    "href": "01-intro-modelling.html#models-in-engineering",
    "title": "1  Introduction to Modelling",
    "section": "1.2 Models in Engineering",
    "text": "1.2 Models in Engineering\nIn engineering, models are a common way to: * Communicate with clients * Mitigate risks * Plan work\nBefore building a complex and expensive system, engineers create and learn from models.",
    "crumbs": [
      "<span class='chapter-number'>1</span>  <span class='chapter-title'>Introduction to Modelling</span>"
    ]
  },
  {
    "objectID": "01-intro-modelling.html#modelling-languages",
    "href": "01-intro-modelling.html#modelling-languages",
    "title": "1  Introduction to Modelling",
    "section": "1.3 Modelling Languages",
    "text": "1.3 Modelling Languages\nTo describe (model) an information system, several types of languages can be used, which exist on a spectrum from informal to formal.\n\n1.3.0.1 Natural Language (e.g., English)\n\nAdvantages: No learning required (if terms are well understood), accessible to all.\nDisadvantages: Often verbose and subject to the “7 deadly sins” such as ambiguity, noise (useless information), contradiction, silence (under-specification), etc..\n\n\n\n1.3.0.2 Ad-hoc Notations (informal drawings)\n\nAdvantages: No learning required (if symbols are understood).\nDisadvantages: No well-defined syntax, no common interpretation (semantics), leading to a risk of ambiguity.\n\n\n\n1.3.0.3 Semi-Formal Notations (e.g., UML)\n\nAdvantages: Well-defined syntax, often visual and more intuitive, partial common interpretation, allow for partial automation (reasoning, code generation), fast learning curve.\nDisadvantages: Ambiguities are still possible.\n\n\n\n1.3.0.4 Formal Notations (e.g., Z, VDM)\n\nAdvantages: Well-defined syntax, unambiguous mathematical interpretation, allow for greater automation.\nDisadvantages: Often difficult for non-experts to read, long learning curve.",
    "crumbs": [
      "<span class='chapter-number'>1</span>  <span class='chapter-title'>Introduction to Modelling</span>"
    ]
  },
  {
    "objectID": "01-intro-modelling.html#qualities-of-a-good-model",
    "href": "01-intro-modelling.html#qualities-of-a-good-model",
    "title": "1  Introduction to Modelling",
    "section": "1.4 Qualities of a Good Model",
    "text": "1.4 Qualities of a Good Model\nTo be effective, a model must be more than just a picture; it must possess specific qualities that make it useful for its intended purpose. The famous statistician George E.P. Box aptly noted:\n\n“Essentially, all models are wrong, but some are useful.”\n— George E.P. Box\n\nThe usefulness of a model can be evaluated across three distinct dimensions: its syntax, its semantics, and its pragmatics.\n\n1.4.1 Syntactic Quality: Is the Model Well-Formed?\nThis dimension concerns the structure and comprehensibility of the model itself, independent of what it represents.\n\nUnderstandable: The model must use a notation that is clear and intuitive for its intended audience, whether they are domain experts, developers, or clients. A model that cannot be easily understood fails its primary purpose of communication.\n\n\n\n1.4.2 Semantic Quality: Does the Model Represent Reality Faithfully?\nThis is about the relationship between the model and the system it represents. The goal is to ensure the model is a truthful representation.\n\nAbstract: A model must be an effective abstraction, focusing on the essential aspects of the system while intentionally omitting irrelevant details. This is the primary mechanism for managing complexity.\nPrecise: Precision is a measure of how faithfully the model reflects reality. It encompasses several sub-qualities:\n\nCorrectness: The model does not contain any information that is false with respect to the system.\nCompleteness: The model includes all relevant information for its purpose.\nLack of Ambiguity: The statements made by the model have one and only one interpretation.\n\n\n\n\n1.4.3 Pragmatic Quality: Is the Model Useful for its Purpose?\nThis dimension evaluates the model’s utility in practice. A model can be well-formed and accurate but still be useless if it doesn’t serve its purpose.\n\nPredictive: The model must allow us to deduce non-trivial properties about the system it represents. It should be a tool for analysis and reasoning, helping us answer “what if” questions.\nInexpensive: The cost of creating, analyzing, and maintaining the model must be significantly lower than the cost of experimenting with the actual system. If the model is as complex or expensive as the system itself, it loses its pragmatic value.",
    "crumbs": [
      "<span class='chapter-number'>1</span>  <span class='chapter-title'>Introduction to Modelling</span>"
    ]
  },
  {
    "objectID": "01-intro-modelling.html#what-is-modelling",
    "href": "01-intro-modelling.html#what-is-modelling",
    "title": "1  Introduction to Modelling",
    "section": "1.1 What is Modelling?",
    "text": "1.1 What is Modelling?\nIn software engineering, “modelling” is often misunderstood and reduced to clichés: drawing diagrams because a process demands it, or simply creating documentation.\n\n\n\nA cliché representation of modelling, with complex and confusing shapes connected by arrows.\n\n\nIn reality, modelling is a rigorous intellectual activity focused on understanding and communicating complex systems.\n\n1.1.1 The Problem Space vs. The Solution Space\nA critical distinction in advanced modelling is the separation between two domains:\n\nThe Problem Space: This refers to the real-world environment, with all its complexities, rules, and stakeholders. A model in this space aims to understand and formalize the “what” — what is the problem to be solved?\nThe Solution Space: This refers to the computational system we intend to build. A model in this space specifies the “how” — how will our software be structured and behave to solve the problem?\n\nEffective modelling involves creating a clear and verifiable bridge between these two spaces.\n\n\n1.1.2 A More Formal Definition\nAccording to Jeff Rothenberg, a model is a simplification of reality that allows us to reason about the world in a more manageable way. Building on this, we can define a model as:\n\nA simplification of a real or imagined reality…\n…that captures its essential properties…\n…to help us understand and reason about it…\n…for a specific cognitive purpose (e.g., analysis, simulation, code generation).\n\nA good model must not only be an abstraction but also possess qualities of the original system, allowing us to perform meaningful analysis and make predictions about the system’s behaviour.",
    "crumbs": [
      "<span class='chapter-number'>1</span>  <span class='chapter-title'>Introduction to Modelling</span>"
    ]
  },
  {
    "objectID": "01-intro-modelling.html#the-role-of-models-in-engineering",
    "href": "01-intro-modelling.html#the-role-of-models-in-engineering",
    "title": "1  Introduction to Modelling",
    "section": "1.2 The Role of Models in Engineering",
    "text": "1.2 The Role of Models in Engineering\nIn any engineering discipline, building a complex system without prior modelling is unthinkable. Before investing significant resources, engineers create and learn from models to manage complexity and ensure the final product meets its requirements. In software engineering, models serve three critical roles throughout the development lifecycle:\n\n1.2.1 Models for Analysis (Understanding the Problem)\nModels are first and foremost tools for thought and communication. They help us analyze the problem space by:\n\nClarifying Requirements: Translating ambiguous client needs into a precise, structured representation that can be discussed and validated.\nExploring the Domain: Capturing the essential concepts, rules, and relationships of the business domain, ensuring the development team shares a common understanding.\n\n\n\n1.2.2 Models for Synthesis (Designing the Solution)\nOnce the problem is understood, models guide the design of the solution space. They serve as blueprints for construction, helping to:\n\nArchitect the System: Defining the high-level structure, components, and interactions of the software.\nPlan Development: Providing a clear plan for implementation, allowing for better task allocation and project management.\n\n\n\n1.2.3 Models for Validation (Mitigating Risks)\nFinally, models allow us to validate our design choices before writing a single line of production code, thereby mitigating risks. This can be done through:\n\nSimulations and Walkthroughs: “Executing” the model mentally or with tools to identify logical flaws or unintended consequences.\nFormal Verification: Applying mathematical techniques to prove that a model satisfies certain critical properties (e.g., security, safety).",
    "crumbs": [
      "<span class='chapter-number'>1</span>  <span class='chapter-title'>Introduction to Modelling</span>"
    ]
  },
  {
    "objectID": "01-intro-modelling.html#the-spectrum-of-modelling-languages",
    "href": "01-intro-modelling.html#the-spectrum-of-modelling-languages",
    "title": "1  Introduction to Modelling",
    "section": "1.3 The Spectrum of Modelling Languages",
    "text": "1.3 The Spectrum of Modelling Languages\nTo describe an information system, engineers use various languages that fall along a spectrum, balancing the trade-off between intuitive expressiveness and formal precision. Choosing the right language depends on the context, the audience, and the goals of the model.\n\n1.3.1 Informal Languages\nThese languages prioritize ease of communication and are accessible to all stakeholders, including non-technical clients.\n\n1.3.1.1 Natural Language (e.g., English, French)\nNatural language is the default for initial requirements gathering.\n\nStrengths: Universally understood, requires no special training.\nWeaknesses: Highly prone to what are known as the “7 deadly sins” of specification: ambiguity, contradiction, vagueness, noise (irrelevant information), silence (missing information), over-specification, and wishful thinking. These issues make it unsuitable for detailed and rigorous system design.\n\n\n\n1.3.1.2 Ad-hoc Notations (e.g., whiteboard sketches)\nThese are informal diagrams drawn without strict rules.\n\nStrengths: Excellent for brainstorming and collaborative sessions; highly flexible and fast to create.\nWeaknesses: Lacks a well-defined syntax and semantics. The meaning of a symbol can be interpreted differently by each person, leading to significant ambiguity and making it impossible to automate any analysis.\n\n\n\n\n1.3.2 Formal and Semi-Formal Languages\nAs we move toward implementation, the need for precision increases, requiring languages with well-defined rules.\n\n1.3.2.1 Semi-Formal Notations (e.g., UML)\nThis is the dominant category in modern software engineering. UML (Unified Modelling Language) is the industry standard.\n\nStrengths: Provides a well-defined visual syntax that is more intuitive than purely formal languages. It offers a partial common interpretation (semantics) and supports partial automation, such as code generation and model checking. The learning curve is relatively fast.\nWeaknesses: While the syntax is standardized, UML’s semantics can sometimes remain ambiguous, leaving room for interpretation in complex scenarios.\n\n\n\n1.3.2.2 Formal Notations (e.g., Z, VDM, Alloy)\nThese languages are based on mathematical principles, providing the highest level of precision.\n\nStrengths: Possess a well-defined syntax and an unambiguous mathematical semantics. This rigor eliminates ambiguity and allows for extensive automation, including formal verification and proof of correctness.\nWeaknesses: Their mathematical nature makes them difficult for non-experts to read and requires a significant learning investment. They are typically used for safety-critical or mission-critical systems where absolute correctness is paramount.\n\n\n\n\n1.3.3 Summary Comparison\n\n\n\nLanguage Type\nSyntax\nSemantics\nAmbiguity\nTool Support\n\n\n\n\nNatural Language\nUndefined\nInformal\nVery High\nLow\n\n\nAd-hoc\nUndefined\nInformal\nHigh\nVery Low\n\n\nSemi-Formal (UML)\nDefined\nPartially Formal\nLow\nHigh\n\n\nFormal (Z, VDM)\nDefined\nFormal\nVery Low\nVery High",
    "crumbs": [
      "<span class='chapter-number'>1</span>  <span class='chapter-title'>Introduction to Modelling</span>"
    ]
  },
  {
    "objectID": "02-intro-uml.html",
    "href": "02-intro-uml.html",
    "title": "2  Introduction to UML",
    "section": "",
    "text": "2.1 UML in a Nutshell\nThis chapter provides an overview of the Unified Modelling Language (UML), the industry-standard language for specifying, visualizing, constructing, and documenting the artifacts of software systems.\nUML is a general-purpose visual Modelling language designed to provide a standard way to visualize the design of a system. It is crucial to understand what UML is and what it is not:\nDespite some criticisms, UML remains the undisputed leader in software Modelling, supported by a vast number of tools and methods.",
    "crumbs": [
      "<span class='chapter-number'>2</span>  <span class='chapter-title'>Introduction to UML</span>"
    ]
  },
  {
    "objectID": "02-intro-uml.html#uml-in-a-nutshell",
    "href": "02-intro-uml.html#uml-in-a-nutshell",
    "title": "2  Introduction to UML",
    "section": "",
    "text": "Unified: It is an industry standard managed by the Object Management Group (OMG), an international consortium of major software companies like IBM and Microsoft. Its goal is to be the lingua franca for business analysts, software architects, and developers.\nModelling: It is primarily a graphical language used to create models of both application domains (the problem) and software systems (the solution).\nLanguage: It provides a set of notations (diagrams) but is not a method or a process. A process provides guidance on the order of activities and the artifacts to be developed, whereas UML is intentionally process-independent.",
    "crumbs": [
      "<span class='chapter-number'>2</span>  <span class='chapter-title'>Introduction to UML</span>"
    ]
  },
  {
    "objectID": "02-intro-uml.html#history-and-philosophy",
    "href": "02-intro-uml.html#history-and-philosophy",
    "title": "2  Introduction to UML",
    "section": "2.2 History and Philosophy",
    "text": "2.2 History and Philosophy\nUML was created in the mid-1990s from the unification of several popular object-oriented modelling methods, most notably those of Booch, Rumbaugh (OMT), and Jacobson (OOSE), often called the “three amigos”. It was standardized by the OMG in November 1997 (UML 1.1) and has evolved significantly since then, with the current version being UML 2.5.\nThe philosophy behind UML is one of unification by union, rather than intersection. This means it aims to be highly versatile and capable of representing entire systems across various domains like real-time systems, banking, and scientific applications.\nThis versatility, however, comes with a trade-off:\n\nPros: UML is a well-accepted standard, versatile, and supported by many tools.\nCons: It can be overly complex, with “too many constructs for some concerns and missing ones for others”. It also has a relative lack of formality and coordination between its various notations, which can lead to ambiguity.",
    "crumbs": [
      "<span class='chapter-number'>2</span>  <span class='chapter-title'>Introduction to UML</span>"
    ]
  },
  {
    "objectID": "02-intro-uml.html#uml-diagrams-an-overview",
    "href": "02-intro-uml.html#uml-diagrams-an-overview",
    "title": "2  Introduction to UML",
    "section": "2.3 UML Diagrams: An Overview",
    "text": "2.3 UML Diagrams: An Overview\nUML provides a wide range of diagrams to model different aspects of a system. These are broadly categorized into two main types: Structure Diagrams and Behaviour Diagrams.\n\n\n\nA diagram showing the hierarchy of UML diagrams, separating Structure and Behaviour diagrams.\n\n\n\n2.3.1 Structure Diagrams (Static View)\nThese diagrams depict the static structure of the system, its components, and the relationships between them at different levels of abstraction. They represent the elements that must be present in the system being modelled.\n\nClass Diagram: The cornerstone of object-oriented modelling. It describes the structure of a system by showing its classes, attributes, operations, and the relationships among them.\nComponent Diagram: Depicts how a software system is split into modular components and shows the dependencies and interfaces among these components.\nDeployment Diagram: Models the physical deployment of artifacts on nodes. It shows the hardware of your system and the software deployed on that hardware.\nObject Diagram: Shows a snapshot of the instances in a system, the objects and their relationships, at a particular point in time. It is often considered a special case of a class diagram.\nPackage Diagram: Organizes elements of a system into groups (packages) to manage complexity. It shows the dependencies between these packages.\nComposite Structure Diagram: Shows the internal structure of a class and the collaborations that this structure makes possible.\nProfile Diagram: A specialized diagram used for extending the UML metamodel for specific platforms or domains.\n\n\n\n2.3.2 Behaviour Diagrams (Dynamic View)\nThese diagrams illustrate the dynamic behaviour of the system, focusing on how its components interact and change over time. They represent what happens in the system being modelled.\n\nUse Case Diagram: Describes the high-level functions of a system from an external point of view, showing how users (actors) interact with it to achieve specific goals.\nActivity Diagram: Shows the flow of control or data through a system, useful for Modelling business processes, complex operational workflows, or algorithms.\nState Machine Diagram: Models the behaviour of a single object, specifying the sequence of states it goes through during its lifetime in response to events.\nSequence Diagram: An interaction diagram that emphasizes the time-ordering of messages between objects or components. It is particularly useful for understanding the chronology of method calls.\nCommunication Diagram: (Formerly Collaboration Diagram) Another type of interaction diagram that emphasizes the structural organization of the objects that send and receive messages, rather than the time-ordering.\nInteraction Overview Diagram: A hybrid of an Activity Diagram and Sequence Diagrams. It provides a high-level view of the control flow of an interaction, where individual steps can be represented as more detailed sequence diagrams.\nTiming Diagram: An interaction diagram that focuses on the timing constraints of messages, showing how the state of an object changes over a specific timeline.\n\nWhile this course will not cover every diagram in detail, this complete overview provides the necessary context for understanding the full scope and power of UML. Our focus will remain on a core subset most critical for the analysis and design phases.",
    "crumbs": [
      "<span class='chapter-number'>2</span>  <span class='chapter-title'>Introduction to UML</span>"
    ]
  },
  {
    "objectID": "03-class-diagrams.html",
    "href": "03-class-diagrams.html",
    "title": "3  Class and Object Diagrams",
    "section": "",
    "text": "3.1 Overview of Class Diagrams\nThis chapter focuses on the cornerstone of UML’s structural modelling: the Class Diagram. We will explore its fundamental components, the different types of relationships between classes, and its practical applications in both the analysis and design phases of software development. We will also briefly introduce the Object Diagram, which provides a snapshot of a class diagram’s instances at a specific moment in time.\nA UML Class Diagram specifies the static structure of a system. It is the most common and essential diagram in object-oriented modelling, with its origins in earlier formalisms like Entity-Relationship-Attribute (ERA) models and the Object-modelling Technique (OMT).\nIts primary purpose is to show the system’s classes, interfaces, their attributes and operations, and the relationships between them.",
    "crumbs": [
      "<span class='chapter-number'>3</span>  <span class='chapter-title'>Class and Object Diagrams</span>"
    ]
  },
  {
    "objectID": "03-class-diagrams.html#overview-of-class-diagrams",
    "href": "03-class-diagrams.html#overview-of-class-diagrams",
    "title": "3  Class and Object Diagrams",
    "section": "",
    "text": "3.1.1 Multi-Purpose Usage\nClass diagrams are versatile and used throughout the software lifecycle. Their purpose often determines which constructs are used and how they are interpreted:\n\nAnalysis (Conceptual Modelling): In this phase, class diagrams are used to model the concepts of the application domain. These models, often called Domain Models, focus on real-world entities and their relationships, deliberately omitting software-specific details like operations or visibility. \nDesign (Software Specification): During design, the focus shifts to the solution space. Class diagrams, now called Diagrams of Implementation Classes, specify the software classes, including their attributes, operations (methods), and visibility. They serve as a blueprint for implementation, and class skeletons can often be generated directly from them.",
    "crumbs": [
      "<span class='chapter-number'>3</span>  <span class='chapter-title'>Class and Object Diagrams</span>"
    ]
  },
  {
    "objectID": "03-class-diagrams.html#core-concepts-classes-and-objects",
    "href": "03-class-diagrams.html#core-concepts-classes-and-objects",
    "title": "3  Class and Object Diagrams",
    "section": "3.2 Core Concepts: Classes and Objects",
    "text": "3.2 Core Concepts: Classes and Objects\nThe object-oriented approach decomposes a system based on the “objects” it deals with.\n\n3.2.0.1 Objects\nAn object represents a specific “thing” in the modeled world that has:\n\nAn identity (it is unique).\nA lifespan (it exists over a period of time).\nA state (the set of values for its properties at a given time).\n\n\n\n3.2.0.2 Classes\nSince a system can contain millions of objects, we use classes to manage this complexity. A class is an abstraction that describes a group of objects with common properties (attributes), behavior (operations), and relationships. Every object is an instance of a class.",
    "crumbs": [
      "<span class='chapter-number'>3</span>  <span class='chapter-title'>Class and Object Diagrams</span>"
    ]
  },
  {
    "objectID": "03-class-diagrams.html#anatomy-of-a-class",
    "href": "03-class-diagrams.html#anatomy-of-a-class",
    "title": "3  Class and Object Diagrams",
    "section": "3.3 Anatomy of a Class",
    "text": "3.3 Anatomy of a Class\nA class in UML is typically rendered as a rectangle with three compartments:\n\nName: The name of the class.\nAttributes: The properties or data held by each object of the class.\nOperations: The services or functions that each object of the class can perform.\n\n\n\n\nA UML diagram showing a Class with its three compartments: Name, Attributes, and Operations.\n\n\n\n3.3.1 Attributes (The “What it Is”)\nAn attribute represents a property of a class. Think of them as the variables or fields inside an object. The full syntax for an attribute in UML is comprehensive:\n[visibility] name [: type] [multiplicity] [= initial_value] [{constraints}]\nLet’s break this down with an example for our User class:\n- username: String [1] = \"guest\" {readOnly}\n\n\n\n\n\n\n\n\n\nComponent\nSymbol/Syntax\nExample\nDescription\n\n\n\n\nVisibility\n+, -, #, ~\n-\nDefines access level: + (public), - (private), # (protected), ~ (package). This is crucial for encapsulation in the design phase.\n\n\nName\nusername\nusername\nThe name of the attribute.\n\n\nType\n: String\n: String\nThe data type of the attribute (e.g., Integer, boolean, or another class).\n\n\nMultiplicity\n[0..1], [*]\n[1]\nSpecifies how many values the attribute can hold. [1] is the default and means the value is mandatory. [0..1] means it’s optional. [*] means it can be a collection.\n\n\nInitial Value\n= \"guest\"\n= \"guest\"\nAn optional default value for the attribute upon object creation.\n\n\nConstraints\n{readOnly}\n{readOnly}\nAdditional rules that apply to the attribute. {readOnly} means the value cannot be changed after initialization.\n\n\n\n\n\n3.3.2 Operations (The “What it Does”)\nAn operation is a service that can be requested from an object. It corresponds to a method in a programming language. The signature is defined as:\n[visibility] name ([direction] parameter:type, ...) [:return_type]\nLet’s use an example for our User class:\n+ setPassword(newPass: String): boolean\n\n\n\n\n\n\n\n\n\nComponent\nSymbol/Syntax\nExample\nDescription\n\n\n\n\nVisibility\n+, -, #, ~\n+\nDefines the access level, same as for attributes. Public operations define the object’s interface.\n\n\nName\nsetPassword\nsetPassword\nThe name of the operation.\n\n\nParameters\n(name:type)\n(newPass:String)\nThe arguments the operation accepts. You can also specify direction (in, out, inout).\n\n\nReturn Type\n: boolean\n: boolean\nThe data type of the value the operation returns. If omitted, it’s assumed to be void.\n\n\n\n\n3.3.2.1 Abstract vs. Concrete Operations\nUML allows us to specify whether an operation has an implementation.\n\nAn abstract operation is shown in italics. It declares a signature but has no implementation. This forces subclasses to provide a concrete implementation.\nA class that contains at least one abstract operation is an abstract class (its name is also shown in italics) and it cannot be instantiated directly. This is a fundamental concept for creating flexible and extensible frameworks.",
    "crumbs": [
      "<span class='chapter-number'>3</span>  <span class='chapter-title'>Class and Object Diagrams</span>"
    ]
  },
  {
    "objectID": "03-class-diagrams.html#relationships-between-classes",
    "href": "03-class-diagrams.html#relationships-between-classes",
    "title": "3  Class and Object Diagrams",
    "section": "3.4 Relationships Between Classes",
    "text": "3.4 Relationships Between Classes\nRelationships describe the connections between classes.\n\n3.4.1 Association\nAn association is a structural relationship that specifies that objects (instances) of one class are connected to objects of another. It is the most fundamental way to represent connections in a class diagram.\nAn association is typically drawn as a solid line connecting two classes. Several adornments can be added to this line to specify the relationship with greater precision.\n\n\n\nA UML diagram showing a detailed association between Professor and Book.\n\n\nLet’s break down the components of an association using the example above:\n\nAssociation Name: The name of the association is typically a verb that describes the relationship. It is placed near the middle of the association line. In our example, the name is Wrote. A small triangle can be added to indicate the reading direction (e.g., “Professor Wrote Book”).\nAssociation Ends (Roles): Each end of the association connects to a class and represents a “role” that the class plays in the relationship. These ends can have several properties:\n\nRole Name: An optional name describing the role played by the class at that end. For example, the Professor class plays the role of author, and the Book class plays the role of textbook.\nMultiplicity: This is a mandatory constraint that specifies how many instances of the class can participate in one instance of the association. In the example, 1..* on the author side means a Book must be written by at least one Professor. The 0..* on the textbook side means a Professor can have written zero or many Books.\nNavigability: This specifies whether instances of one class can be efficiently accessed from an instance of the class at the other end of the association. It is a critical concept for bridging the gap between design models and implementation. The notation is as follows:\n\nAn open arrowhead on an association end indicates that it is navigable.\nA small ‘x’ on an end indicates it is explicitly not navigable.\nNo adornment on an end means that navigability is unspecified.\n\n\n\n\nBoth ends of the association have unspecified navigability.\n\n\n\n\n\nA2 has unspecified navigability while B2 is navigable from A2.\n\n\n\n\n\nA3 is not navigable from B3 while B3 has unspecified navigability.\n\n\n\n\n\nA4 is not navigable from B4 while B4 is navigable from A4.\n\n\n\n\n\nA5 is navigable from B5 and B5 is navigable from A5.\n\n\n\n\n\nA6 is not navigable from B6 and B6 is not navigable from A6.\n\n\nIt is important to understand the sometimes confusing semantics behind non-navigability in the UML specification. While one definition states that a non-navigable end means “access from the other ends may or may not be possible, and if it is, it might not be efficient,” this can be functionally ambiguous.\nA more formal, though sometimes contradictory, definition in UML links navigability to ownership: an end is considered navigable if it is owned by the opposite class. This highlights an advanced concept where a navigable role is often implemented as an attribute in the opposite class.\n\nOwnership: An association end can be formally “owned” by either the class at the opposite end or by the association itself. This is an advanced concept that hints at the implementation. Ownership by the opposite class is indicated by a small filled circle (dot) at the end of the line. This notation implies that the role will be implemented as an attribute in the owning class.\n\n\n\nAn example of ownership in a UML association.\n\n\nIn the example above, the dot on the Query end signifies that the query role is owned by the Query Builder class. This suggests that the QueryBuilder class will contain an attribute named query of type Query.\n\n\n\n3.4.2 Aggregation: The “Has-A” Relationship\nShared aggregation, commonly known as Aggregation, represents a “weak” whole-part relationship. It signifies that a composite object groups together a set of part instances, but these parts can exist independently of the whole.\nAggregation has the following key characteristics:\n\nIt is a binary and asymmetric relationship; only one end of the association (the “whole”) can be marked as an aggregate.\nThe relationship is transitive, meaning aggregation links must form a directed, acyclic graph. An object cannot be a direct or indirect part of itself.\nThe “part” can be included in several composites simultaneously, and if the composite “whole” is deleted, the part may still exist.\n\nNotation: Aggregation is depicted as an association with a hollow diamond at the “whole” or aggregate end of the line.\n\n\n\nA UML diagram showing that a Triangle is an aggregation of three Line Segments.\n\n\nIn the example above, a Triangle is an aggregate of exactly three Segment. The * multiplicity at the Triangle end signifies that a Segment can be a part of multiple triangles or none at all. Deleting a Triangle object does not delete the Segment objects.\n\n3.4.2.1 Common Mistakes with Aggregation\n{#sec-common-mistakes}\nIt is crucial to use aggregation correctly to avoid creating logically inconsistent models. Here are two common mistakes to avoid:\nMistake 1: Marking both ends as an aggregate. Aggregation is an asymmetric relationship. The UML specification does not allow a diamond on both ends of an association line. This is an incorrect attempt to model a many-to-many relationship where, for example, a Student has a list of Course and a Course has a list of Student. The correct way to model this is with a simple association or an association class.\n\n\n\nAn incorrect UML diagram with aggregation diamonds on both ends of an association.\n\n\nMistake 2: Creating cyclic relationships. Aggregation links must form a directed, acyclic graph. This means a composite object cannot be a direct or indirect part of itself. Creating a cycle where Student is part of Course and Course is part of Student is a logical error.\n\n\n\nAn incorrect UML diagram showing a cyclic aggregation.\n\n\n\n\n\n3.4.3 Composition: The “Owns-A” Relationship\nComposition represents a “strong” form of aggregation with co-incident lifetime of the parts with the whole. It’s a whole/part relationship where a part can belong to at most one composite (whole) at a time.\nNotation: Composition is depicted as an association with a filled black diamond at the aggregate (whole) end.\n\n\n\nA UML diagram showing that a Folder is a composition of multiple Files.\n\n\nComposition has the following key characteristics:\n\nExistential Dependency: If a composite (whole) is deleted, all of its composite parts are normally deleted with it. In the example above, if a Folder is deleted, all Files it contains are also deleted.\nExclusive Ownership: A part can only belong to one whole at a time. A File cannot be in two different Folder simultaneously.\nFigurative Interpretation: In domain models, the concept of “deletion” should be interpreted figuratively. For example, if a Hospital is composed of Department, closing the hospital also implies closing all its departments, even if the objects are not physically destroy.\n\n\n\n\nA UML diagram showing that a Hospital is a composition of multiple Departments.\n\n\nIt’s also important to note that the UML specification does not dictate how or when the parts of a composite are created. Furthermore, a part can sometimes be removed from a composite before the whole is deleted, allowing it to survive independently in specific cases.\nInterestingly, the multiplicity of the composite (whole) end can be 0..1, which means that a part is allowed to exist as a “stand-alone” instance, not owned by any specific composite at a particular time. Because Composition is a strong form of aggregation, it is subject to the same structural rules, and the common mistakes, previously discussed, apply to it as well.\n\n\n3.4.4 Generalization (Inheritance)\nGeneralization is a directed, taxonomic relationship between a more general classifier (the superclass) and a more specific classifier (the subclass). Each instance of the subclass is also considered an instance of the superclass, which is why this is informally known as an “Is A” relationship (e.g., a Patient is a Person).\nNotation: Generalization is shown as a solid line with a hollow triangle arrowhead pointing from the subclass to the superclass.\n\n\n\nA UML diagram showing Checking, Savings, and Credit Account classes inheriting from a general Account class.\n\n\n\n3.4.4.1 Inheritance Mechanism\nGeneralization is the conceptual relationship, while inheritance is the mechanism that implements it. Through inheritance, a subclass incorporates the structure (attributes) and behaviour (operations) of its superclass. In UML, this means the subclass inherits the features of the more general classifier, and any constraints applying to the superclass also apply to the subclass.\n\n3.4.4.1.1 Multiple Inheritance\nUML implicitly allows a class to have more than one superclass, a concept known as multiple inheritance. This is often used when combining orthogonal classification schemes (e.g., classifying an Employee by contract type and by role).\n\n\n\nA diagram illustrating the multiple inheritance.\n\n\nHowever, multiple inheritance introduces complexities, most famously the “diamond problem.” If a class inherits from two superclasses that both provide an implementation for the same operation, it becomes ambiguous which implementation the subclass should use. UML does not define a standard resolution for this issue, leaving it to the implementation language (e.g., Java prohibits multiple inheritance of classes to avoid this).\n\n\n\nA diagram illustrating the diamond problem in multiple inheritance.\n\n\n\n\n\n3.4.4.2 Generalization Sets\nTo add more precision to classification hierarchies, UML provides the Generalization Set. This is a way to group related generalization relationships and apply constraints to them. The two main constraints are:\n\n{complete} vs. {incomplete}:\n\n{complete}: Specifies that every instance of the superclass must also be an instance of at least one of the subclasses in the set. There are no “standalone” instances of the superclass.\n{incomplete}: Allows for instances of the superclass that do not belong to any of the specified subclasses. This is the default.\n\n{disjoint} vs. {overlapping}:\n\n{disjoint}: Specifies that an instance of the superclass can be an instance of at most one of the subclasses in the set.\n{overlapping}: Allows an instance of the superclass to be an instance of multiple subclasses in the set simultaneously.\n\n\nA generalization set that is {disjoint, complete} is known as a partition. This means every instance of the superclass is an instance of exactly one of the subclasses.\nThese constraints are written near the generalization arrowhead, often next to a dashed line connecting the generalization arrows.\n\n\n\nAn example of generalization sets for a Health Insurance Policy.\n\n\nIn the example above, the Health Insurance Policy has two different generalization sets:\n\nThe set based on CoverageType is {complete, overlapping}. This means every policy must have at least one coverage type, and a single policy could potentially be both a Job Based Insurance and a Self Insurance.\nThe set based on InsurancePlan is {incomplete, disjoint}. This means a policy can be at most one type of plan (e.g., either HMO or PPO, but not both), and there might be other types of plans not listed in the diagram.",
    "crumbs": [
      "<span class='chapter-number'>3</span>  <span class='chapter-title'>Class and Object Diagrams</span>"
    ]
  },
  {
    "objectID": "03-class-diagrams.html#object-diagrams",
    "href": "03-class-diagrams.html#object-diagrams",
    "title": "3  Class and Object Diagrams",
    "section": "3.5 Object Diagrams",
    "text": "3.5 Object Diagrams\nWhile a class diagram models the types, an Object Diagram shows a snapshot of the instances in a system at a particular point in time. It shows objects (instances of classes), their attribute values (slots), and the links between them (instances of associations).\nObject diagrams are very useful for illustrating or validating a class diagram by showing concrete examples of how objects will be structured and linked at runtime.",
    "crumbs": [
      "<span class='chapter-number'>3</span>  <span class='chapter-title'>Class and Object Diagrams</span>"
    ]
  },
  {
    "objectID": "03-class-diagrams.html#core-concepts-the-blueprint-and-the-product",
    "href": "03-class-diagrams.html#core-concepts-the-blueprint-and-the-product",
    "title": "3  Class and Object Diagrams",
    "section": "3.2 Core Concepts: The Blueprint and the Product",
    "text": "3.2 Core Concepts: The Blueprint and the Product\nThe object-oriented approach is built upon two fundamental concepts: the class and the object. The easiest way to understand their relationship is through an analogy: a class is like a cookie cutter, and an object is the cookie it creates.\n\n3.2.1 The Class: A Blueprint or Template\nA class is an abstraction that serves as a blueprint for creating objects. It defines a common structure and behaviour that all objects of that type will share. Just as a cookie cutter defines the shape and pattern for all cookies made from it, a class defines:\n\nProperties (Attributes): The data or characteristics that each object will have (e.g., a User class defines that every user will have a name and an email).\nbehaviour (Operations): The actions or functions that each object can perform (e.g., a User class defines that every user can login() or logout()).\n\n\n\n\n\n\n\nFormal Definition\n\n\n\nA class is an abstraction that describes a group of objects with common properties (attributes), behaviour (operations), and relationships.\n\n\n\n\n3.2.2 The Object: A Concrete Instance\nAn object is a concrete instance of a class. It’s a specific “thing” that exists in the system, created from the blueprint defined by its class. Just as you can use one cookie cutter to make many individual cookies, you can use one class to create many objects.\nEvery object has:\n\nIdentity: It is a unique entity, distinct from all other objects, even those of the same class (e.g., two different User objects, user1 and user2).\nState: It holds specific values for the attributes defined in its class (e.g., user1’s name is “Alice”, while user2’s name is “Bob”).\nLifespan: It exists in the system for a certain period, from its creation to its destruction.\n\n\n\n\n\n\n\nFormal Definition\n\n\n\nAn object represents a specific “thing” in the modelled world that has a unique identity, a state, and a lifespan. Every object is an instance of a class.",
    "crumbs": [
      "<span class='chapter-number'>3</span>  <span class='chapter-title'>Class and Object Diagrams</span>"
    ]
  },
  {
    "objectID": "03-class-diagrams.html#anatomy-of-a-class-the-utility-class-example",
    "href": "03-class-diagrams.html#anatomy-of-a-class-the-utility-class-example",
    "title": "3  Class and Object Diagrams",
    "section": "3.3 Anatomy of a Class: The Utility Class Example",
    "text": "3.3 Anatomy of a Class: The Utility Class Example\nA class in UML is rendered as a rectangle, typically with three compartments: Name, Attributes, and Operations. Let’s analyze these components through a common and instructive pattern: the utility class, as exemplified by the Math class.\nA utility class is a class that only contains static members (attributes and operations) and is not intended to be instantiated.\n\n\n\nA UML diagram of the Math utility class.\n\n\n\n3.3.1 Attributes (Class Properties)\nAn attribute represents a property of a class. The Math class example introduces a crucial distinction:\n\nInstance Attribute: Belongs to a specific object. Its value is unique to that instance.\nClass Attribute (Static): A single value is shared across all instances of the class, or more accurately, it belongs to the class itself. In UML, a class attribute is denoted by being underlined.\n\nThe full syntax for an attribute remains: [visibility] name [: type] [multiplicity] [= initial_value] [{constraints}]\nLet’s break down an attribute from our example: + PI: double = 3.1415926 {readOnly}\n\n\n\n\n\n\n\n\nComponent\nExample\nDescription\n\n\n\n\nVisibility\n+\nDefines the access level. + (public) is common for constants.\n\n\nName\nPI\nThe name of the attribute. Note: if this were a true static member, it would be underlined (&lt;u&gt;PI&lt;/u&gt;).\n\n\nType\n: double\nThe data type of the attribute.\n\n\nInitial Value\n= 3.1415926\nA default value. For a constant, this is its only value.\n\n\nConstraints\n{readOnly}\n{readOnly} signifies that the attribute is a constant and cannot be changed.\n\n\n\n\n\n3.3.2 Operations (Class Methods)\nAn operation is a service that can be requested. As with attributes, operations can be instance-level or class-level (static). In a utility class like Math, all operations are static.\nThe signature is defined as: [visibility] name ([parameter:type], ...) [:return_type]\nThis example introduces several key object-oriented concepts:\n\n3.3.2.1 Private Constructor\nThe Math class has a private constructor: - Math(). * Purpose: This is a design pattern used to prevent instantiation. It makes it impossible for a developer to create an object of the class (e.g., new Math() would be forbidden). This enforces the class’s role as a pure utility/helper.\n\n\n3.3.2.2 Class Operations (Static Methods)\nAll public methods in the Math class are static (and should be underlined in a strict UML diagram). This means they are called on the class itself, not on an instance. * Example Call: double result = Math.sin(3.14); * Example from Diagram: + sin(double): double\n\n\n3.3.2.3 Method Overloading\nThe Math class provides two versions of the max operation: * + max(int, int): int * + max(long, long): long\nThis is called overloading: defining multiple operations with the same name but different parameter lists (either different types or a different number of parameters). The compiler or interpreter selects the correct one to call based on the arguments provided.\n\n\n3.3.2.4 Abstract vs. Concrete Operations\n(This concept is not illustrated by the Math class, but remains important.) An operation shown in italics is abstract: it has no implementation and must be implemented by a subclass. A class containing an abstract operation is itself an abstract class. The Math class is concrete and also final (as denoted by {leaf}), meaning it cannot be subclassed.",
    "crumbs": [
      "<span class='chapter-number'>3</span>  <span class='chapter-title'>Class and Object Diagrams</span>"
    ]
  },
  {
    "objectID": "03-class-diagrams.html#anatomy-of-a-class-a-comparative-example",
    "href": "03-class-diagrams.html#anatomy-of-a-class-a-comparative-example",
    "title": "3  Class and Object Diagrams",
    "section": "3.3 Anatomy of a Class: A Comparative Example",
    "text": "3.3 Anatomy of a Class: A Comparative Example\nA class in UML is rendered as a rectangle with three compartments: Name, Attributes, and Operations. To understand how these components are used in practice, we will compare two common but fundamentally different design patterns: a stateless utility class (Math) and a stateful service class (SearchService).\n\n\n\n\n\nA UML diagram of the Math utility class.\n\n\nA utility class groups related functions but has no state. It is not meant to be instantiated.\n\n\n\n\n\nA UML diagram of the SearchService class.\n\n\nA service class encapsulates data (state) and provides operations that act on that data. It is designed to be instantiated.\n\n\n\n3.3.1 Attributes: State vs. Constants\nAn attribute represents a property of a class. Our two examples illustrate the critical difference between class-level constants and instance-level state.\n\nIn the Math class, attributes like + PI: double = 3.14 are constants. They are public, read-only, and their values are shared across the entire system. In a strict UML diagram, they would be underlined to indicate they are static.\nIn the SearchService class, attributes like - config: Configuration and - engine: SearchEngine are instance attributes. This means every SearchService object has its own configuration and search engine. This is the internal state of the object, which is kept private (-) to ensure encapsulation.\n\n\n\n3.3.2 Operations: Static Functions vs. Instance Methods\nAn operation is a service that can be requested. This is where the difference between our two classes is most apparent.\n\nIn the Math class, all operations like + sin(double): double are static (underlined). They are self-contained functions that don’t depend on any object’s state. They are called on the class itself (e.g., Math.sin(x)).\nIn the SearchService class, the main operation + search(...) is an instance method. It relies on the internal state of the object (e.g., the engine attribute) to perform its function. You must create an instance of the class to call it (e.g., mySearchService.search(...)).\n\n\n\n3.3.3 Constructors and Object Creation\nThe constructor is a special operation that creates an object. Its visibility reveals the intended use of the class.\n\nThe Math class has a private constructor (- Math()). This is a deliberate design choice to prevent instantiation. You cannot create a Math object, reinforcing its role as a purely static utility class.\nThe SearchService class would have a public constructor (often implicit if not drawn). This allows users to create multiple instances of the service, each with its own state.\n\nBy comparing these two examples, we can see how the same UML building blocks, classes, attributes, and operations, can be used to model fundamentally different design patterns, each suited for a different purpose.",
    "crumbs": [
      "<span class='chapter-number'>3</span>  <span class='chapter-title'>Class and Object Diagrams</span>"
    ]
  },
  {
    "objectID": "03-class-diagrams.html#object-diagrams-a-snapshot-of-reality",
    "href": "03-class-diagrams.html#object-diagrams-a-snapshot-of-reality",
    "title": "3  Class and Object Diagrams",
    "section": "3.5 Object Diagrams: A Snapshot of Reality",
    "text": "3.5 Object Diagrams: A Snapshot of Reality\nWhile a class diagram models the abstract types, an Object Diagram shows a snapshot of the concrete instances in a system at a particular point in time. It provides a real-world example of the structures defined in a class diagram.\nAn object diagram shows:\n\nObjects: Instances of classes.\nSlots: The current values for the attributes of each object.\nLinks: Instances of the associations between classes.\n\nObject diagrams are invaluable for illustrating complex class diagrams and validating that your abstract model can represent real-world scenarios correctly.\n\n3.5.1 Representing Instances\nIn UML, objects are rendered as instance specifications. The notation is flexible, allowing you to show as much or as little detail as necessary.\nThe most complete notation is InstanceName : ClassName :: Namespace, with all the name underlined.\n\n\n\nA UML diagram showing an object.\n\n\nHere are the common variations:\n\nNamed Instance: order12 : Order - An object named order12 of the Order class.\nAnonymous Instance: :Order - An anonymous (unnamed) object of the Order class.\nInstance of Unknown Class: newPatient : - An object named newPatient whose class is either unknown or not specified.\nFully Specified Instance: front-facing-cam : android.hardware :: Camera - Shows the instance name, class, and the package it belongs to.\n\n\n\n3.5.2 Showing an Object’s State (Slots)\nThe primary purpose of an object diagram is to show the state of objects at a specific moment. This is done by listing slots, which are the attribute names followed by an = and their current value.\nThe type of the attribute can also be specified.\n\n\n\nAn object named ‘newPatient’ of class ‘Patient’, showing the values for its id, name, and gender attributes.\n\n\nIn the example above, the newPatient object shows the following slots:\n\nThe attribute id, of type String, has the value \"38-545-137\".\nThe attribute name has the value \"John Doe\".\nThe attribute gender, of type Gender, has the value \"male\".\n\nThis notation provides a clear and concise snapshot of an object’s state at a point in time.\n\n\n3.5.3 Putting It All Together: A Complex Example\nObject diagrams truly shine when they are used to visualize a snapshot of a complex, real-world system. They serve as a powerful tool to validate that the static model (the class diagram) can accurately represent the dynamic state of the application at runtime.\nThe diagram below shows a snapshot of a user authentication module at a specific moment:\n\n\n\nA complex object diagram showing various instances like LoginController, UserManager, and CookieManager, and the links between them.\n\n\nThis single diagram illustrates several key concepts simultaneously:\n\nNamed and Anonymous Instances: We can see named instances like loginCtrl and anonymous instances like the :UserManager interface.\nSlots with Values: Objects like loginCtrl and :CookieManager show their internal state with specific values assigned to their attributes (e.g., attemptLimit = 5).\nLinks: The lines connecting the objects are links, representing runtime instances of associations. They can show roles (-cookieMgr) and navigability.\nCollections: The diagram even shows a collection of five anonymous instances, demonstrating how multiplicity is represented at the object level.\n\nBy creating such diagrams, developers can reason about specific scenarios, debug potential issues, and communicate the runtime structure of the system to other team members with a high degree of precision.",
    "crumbs": [
      "<span class='chapter-number'>3</span>  <span class='chapter-title'>Class and Object Diagrams</span>"
    ]
  },
  {
    "objectID": "04-practical-exercises-class-diagrams.html",
    "href": "04-practical-exercises-class-diagrams.html",
    "title": "4  Practical Exercises: Class Diagrams",
    "section": "",
    "text": "This chapter provides a series of practical exercises to apply the concepts of UML Class Diagrams discussed previously. Each exercise presents a problem description followed by a detailed solution and an explanation of the key concepts illustrated.\n\n\n4.0.1 Exercise 1: People and Cars\nProblem: Model a system of people and cars. A person is identified by a unique number and is the sole owner of the cars they possess. A car is characterized by a license plate number, a brand, and a date of first registration.\n\n\n\n\n\n\nClick to see the solution\n\n\n\n\n\n\n\n\nUML diagram for the People and Cars exercise.\n\n\nCorrection Details:\n\nPersonne (Person) Class:\n\nAttributes: Contains num: integer as a unique identifier.\nMultiplicity: The * on the voiture (car) role indicates that an instance of Personne can be linked to zero, one, or many instances of Voiture.\n\nVoiture (Car) Class:\n\nAttributes: Contains numeroPlaque: string, marque: string, and dateMiseCirculation.\nMultiplicity: The 1 on the propriétaire (owner) role is a crucial constraint. It means an instance of Voiture must be linked to exactly one instance of Personne. This directly models the “sole owner” requirement from the problem description.\n\npossède (owns) Association:\n\nThis association connects the two classes. The name possède clarifies the nature of the relationship.\nThe role names propriétaire and voiture specify the function each class plays in the relationship, making the diagram easier to read and understand.\n\n\nKey Concepts Illustrated: This introductory exercise is designed to solidify several fundamental concepts:\n\nClass: A class is represented as a rectangle containing its name and attributes. It acts as a blueprint for objects.\nAssociation: An association models a relationship between two classes. Naming the association and its roles is a critical best practice for clarity.\nMultiplicities (Cardinalities): This is the most important concept in this exercise. Multiplicities are constraints that define the exact number of instances that can participate in a relationship, allowing the model to precisely capture business rules like “a car has a single owner”.\n\n\n\n\n\n\n\n4.0.2 Exercise 2: Company Organization\nProblem: Model a company’s organization. A department is identified by a number and has a location. An employee has a unique number within their department (but not necessarily within the company), a name, a role, and the department they work in. An enterprise is composed of departments.\n\n\n\n\n\n\nClick to see the solution\n\n\n\n\n\n\n\n\nUML diagram for the Company Organization exercise.\n\n\nCorrection Details:\n\nEntreprise (Company) Class: The central element of the model. The problem states an enterprise is composed of departments, which strongly implies a whole-part relationship where the parts (departments) cannot exist without the whole. This is modelled with a Composition (filled diamond) relationship to Departement. The multiplicity 1..* signifies that a company must have at least one department.\nDepartement Class:\n\nIt has a numero: integer as an attribute. The problem states an employee’s number is unique within their department, which means the department number itself doesn’t have to be unique across the entire company (though it often is in reality).\nIt is linked to Localisation with a 1..* multiplicity, meaning a department must have at least one location.\nIt has two distinct associations with the Employe class:\n\nThe travail (working in) association has a * multiplicity, meaning a department has zero or more employees.\nThe dirige (manage) association links a department to exactly one directeur (manager), who is an Employe.\n\n\nEmploye Class:\n\nThe diagram shows the attributes matricule: integer, nom: string, prenom: string, age: integer, and grade: string for this class.\nImportant Note: The problem statement specifies that the employee’s number (matricule) is unique within a department, not across the entire company. modelling it as a direct attribute is a valid choice, and this uniqueness constraint would typically be managed at a higher level or with a formal constraint language like OCL.\nThe association to Departement has a multiplicity of 0..1, meaning an employee works for at most one department.\nAn employee (multiplicity of 1) can manage multiple departments, as shown by the directeur role on the dirige (manage) association, which has a multiplicity of * on the Departement side.\n\n\nKey Concepts Illustrated:\n\nComposition: This exercise provides a classic example of Composition. The existential dependency is key: a Departement is fundamentally part of an Entreprise. If the company ceases to exist, its departments do as well. This is a much stronger and more precise relationship than a simple association or aggregation.\nMultiple Associations between Classes: It is common for two classes to be related in more than one way. Here, an Employe has a relationship of “working in” a Departement and a separate relationship of “managing” a Departement. Using distinct, named associations is crucial to model these different roles accurately.\n\n\n\n\n\n\n\n4.0.3 Exercise 3: Geometric Figures\nProblem: A geometric figure can be either simple or composite. A composite figure is made up of several other figures. A simple figure can be a point, a line, a circle, or a square. Any figure can be drawn or translated.\n\n\n\n\n\n\nClick to see the solution\n\n\n\n\n\n\n\n\nUML diagram for the Geometric Figures exercise.\n\n\nCorrection Details:\n\nFigure Class: This class is the core of the hierarchy. It is abstract (indicated by the italicized name) because there is no such thing as a generic “Figure” in this system; a figure must be either simple or composite. It defines a common interface for all figures by declaring two abstract operations: dessiner() and translater(). Any class that inherits from Figure will be required to provide its own implementation for these methods.\nGeneralization Hierarchy: The model uses Generalization (inheritance) to create a clear taxonomy.\n\nFigureSimple and FigureComposee both inherit from Figure. This establishes the primary classification.\nFigureSimple acts as another superclass for the figure types: Point, Ligne, Cercle, and Carre. This creates a neat, two-level hierarchy.\n\nFigureComposee Class: This class models a figure that is made up of other figures.\n\nThe relationship between FigureComposee and Figure is modelled using Aggregation (the hollow diamond). This is a crucial design choice. It’s a “whole-part” relationship, but it’s “weak.” If a FigureComposee is deleted, the Figure it was composed of are not necessarily deleted, as they could be part of another composite figure or exist independently. The 1..* multiplicity indicates that a composite figure must contain at least one other figure.\n\n\nKey Concepts Illustrated:\n\nAbstraction & Inheritance: This is the central theme of the exercise. A common interface (dessiner(), translater()) is defined in an abstract superclass (Figure) and inherited by all subclasses. This allows us to treat all figures uniformly, regardless of their specific type.\nAggregation vs. Composition: This exercise provides a classic example of when to use Aggregation. Since a Figure can exist on its own or be part of multiple composite figures, its lifetime is not tied to a single “whole.” This makes the weaker “has-a” relationship of Aggregation the correct choice over the stronger “owns-a” relationship of Composition.\nPolymorphism: This is the powerful result of the abstraction and inheritance structure. Thanks to polymorphism, we can have a collection of Figure objects and call the dessiner() method on each one. The system will automatically execute the correct implementation of dessiner() based on the object’s actual type (Point, Cercle, FigureComposee, etc.). This allows for highly flexible and extensible code.\n\n\n\n\n\n\n\n4.0.4 Exercise 4: Family Links\nProblem: Define a schema describing the family links of a population of people, identifiable by their national register number.\n\n\n\n\n\n\nClick to see the solution\n\n\n\n\n\n\n\n\nUML diagram for the Family Links exercise.\n\n\nCorrection Details:\n\nPersonne Class: This single class is used to model all individuals in the system. It contains a numeroRegistre: integer attribute, which serves as a unique identifier for each person.\n“épouse” (spouse) Association: This is a reflexive association, meaning it connects the Personne class to itself. It models the marriage relationship.\n\nRoles: The roles conjoint(e) and personne are used to clarify the nature of the link.\nMultiplicities: The 0..1 multiplicity on both ends is a critical constraint. It precisely models a monogamous relationship, where a person can have either zero or one spouse at a time.\n\n“a” (parent/child) Association: This is a second reflexive association on the Personne class, modelling parent-child relationships.\n\nRoles: The roles parent and enfant are absolutely essential here to make the diagram unambiguous. They allow us to read the relationship in two directions: a parent “has” an enfant, and an enfant “has” a parent.\nMultiplicities: The cardinalities are key to capturing the rules of the domain: a person must have exactly 2 parents, while a person acting as a parent can have zero, one, or many (*) children.\n\n\nKey Concepts Illustrated:\n\nReflexive Association: This exercise is a classic example of how a class can be related to itself. This pattern is fundamental for modelling any kind of network or hierarchical structure, such as organizational charts, social networks, or, as seen here, family trees.\nThe Importance of Roles: In reflexive associations, role names are not just helpful; they are indispensable. Without them, it would be impossible to distinguish a parent from a child or a spouse from themselves. They are the primary tool for removing ambiguity in these situations.\nmodelling Domain Constraints: The power of a class diagram comes from its ability to enforce real-world rules through multiplicities. The constraints 0..1 for a spouse and 2 for parents are not arbitrary; they are a direct translation of the rules of our specific domain into a formal model.\n\n\n\n\n\n\n\n4.0.5 Exercise 5: Hotel\nProblem: A hotel is composed of at least two “rooms”. Each room consists of several parts such as bedrooms, washrooms, living rooms, and meeting rooms. Each room has a minimum of one bedroom and one washroom. The washrooms can be bathrooms (with a tub) or shower rooms. A room is also characterized by a price and a number. The hotel itself has a category, and an address. Furthermore, the hotel can host clients, employ staff, and is managed by a staff member.\n\n\n\n\n\n\nClick to see the solution\n\n\n\n\n\n\n\n\nUML diagram for the Hotel exercise.\n\n\nCorrection Details:\n\nPersonne Generalization: The diagram correctly uses Inheritance to model that both Client and Personnel are types of Personne. This is a classic “is-a” relationship that factors out common attributes (like nom, age, adresse) into a general superclass, avoiding redundancy.\nNested Compositions (Whole-Part Relationships): The model features two levels of Composition, indicated by the filled diamonds. This choice is critical and deliberate:\n\nHôtel-Chambre: An Hôtel is composed of 2..* (at least two) Chambre. The filled diamond signifies that a Chambre’s existence is dependent on the Hôtel. If the hotel is demolished, its rooms cease to exist.\nChambre-Pièce: Similarly, a Chambre is composed of 2..* Pièce (parts). A Pièce (like a specific bedroom or bathroom) cannot exist independently of the room it belongs to. This creates a strong structural hierarchy.\n\nPièce Hierarchy: The Pièce class itself is the root of another inheritance hierarchy. It’s an abstract superclass for more specific types like SalleDeReunion, Salon, ChambreACoucher and SalleDEau. SalleDEau is further specialized into SalleDeBain and SalleDeDouche. This demonstrates how inheritance can be used to classify and organize related concepts.\nClient Associations: The Client class is central to two key relationships:\n\nThe héberge (hosts) association links Hôtel to Client. An hotel can host zero or more (*) clients, and a client is hosted by exactly one (1) hotel.\nThe occupe (occupies) association links Client to Chambre. A client can occupy one or more (1..*) rooms, and a room can be occupied by zero or more (*) clients (e.g., a family in one room).\n\nAssociations with Personnel: The Hôtel class has multiple, distinct associations with the Personnel class, highlighting how different relationships can coexist:\n\nemploie (employs): A general association indicating that a hotel employs one or more (1..*) staff members.\ndirige (manages): A more specific association with a directeur role, indicating that the hotel is managed by exactly one (1) member of staff. This shows how roles can be used to add precision to a relationship.\n\n\nKey Concepts Illustrated:\n\nCombining Relationship Types: This is the most important takeaway. A real-world model rarely uses just one type of relationship. This exercise skillfully combines Generalization, Composition, and Association to create a rich and accurate representation of the domain.\nMultiple, Overlapping Hierarchies: This exercise perfectly illustrates how a system can feature different kinds of hierarchies simultaneously.\n\nThere is a clear “is-part-of” hierarchy established through Composition: An Hôtel is composed of Chambres, which are in turn composed of Pièces.\nRunning in parallel, there are two distinct “is-a” hierarchies established through Inheritance:\n\nThe first classifies people: Client and Personnel are specific types of Personne.\nThe second classifies the parts of a room: ChambreACoucher, SalleDEau, Salon, and SalleDeReunion are all types of Pièce. This hierarchy goes even deeper, as SalleDeBain and SalleDeDouche are specific types of SalleDEau. Understanding how to model these different, coexisting structures is a key skill in object-oriented analysis.\n\n\nThe Power of Constraints: The specific multiplicities (2..*, 1, etc.) are not arbitrary. They are a direct translation of the problem description’s rules (“at least two rooms”, “managed by a staff member”) into the formal language of UML, ensuring the model is precise.\n\n\n\n\n\n\n\n4.0.6 Exercise 6: Petri Net\nProblem: A Petri net is a directed graph composed of places, transitions, and arcs. An arc always connects two nodes of different types: either a place and a transition, or the reverse.\nModel a class diagram to represent Petri nets, both with and without tokens. What is the difference?\n\n\n\n\n\n\nClick to see the solution\n\n\n\n\n\n\n\n\nUML diagram for the Petri Net exercise.\n\n\nCorrection Details:\n\nPetriNet Class: This class acts as the root of the model. It has a Composition relationship (filled diamond) with Nœud (Node) and Arc. This is a critical choice: it signifies that the nodes and arcs are integral parts of a specific Petri Net and cannot exist independently. If a PetriNet is deleted, all its constituent elements are deleted as well.\nNœud (Node) Hierarchy and its Associations:\n\nNœud is an abstract class, indicated by its italicized name. This is because a node in a Petri Net must be either a Place or a Transition; it cannot be just a generic “Node”.\nPlace and Transition are concrete classes that inherit from Nœud, correctly modelling the “is-a” relationship.\nThe Nœud class is connected to the Arc class via two associations: débute (starts) and finit (ends). The multiplicities must be read in both directions:\n\nFrom the Arc’s perspective: An Arc must have exactly one source Nœud and exactly one destination Nœud. This is shown by the multiplicity of 1 at the Nœud end of both associations.\nFrom the Nœud’ perspective: A Nœud can be the source of zero or more (*) Arc and the destination of zero or more (*) Arc. This is shown by the * multiplicity at the Arc end of the associations.\n\n\nArc Class and its Associations:\n\nAn Arc has two mandatory (1) associations with the Nœud class: one for its source (débute) and one for its destination (finit). This accurately models that every arc connects exactly two nodes.\nThe problem states that an arc must connect a Place to a Transition or vice-versa. This is a complex constraint that is difficult to represent visually in a class diagram alone. It would typically be specified using a formal constraint language like OCL (Object Constraint Language).\n\nToken Class:\n\nThe Token class represents the dynamic part of the model. Its association se situe (is located) connects it to the Nœud class.\nMultiplicities: The cardinalities are critical. The * (many) on the Token side and 1 (exactly one) on the Nœud side mean that a Nœud can contain zero or more Token, but a Token must be located in exactly one Nœud at any given time.\n\n\nKey Concepts Illustrated:\n\nmodelling a Meta-Structure (Metamodelling): This is the most advanced concept in these exercises. The class diagram is not modelling a typical business domain (like a hotel or a company). Instead, it is modelling the structure of another model, the Petri Net. This is a powerful technique used to define the “rules” of a language or a diagramming technique.\nStatic vs. Dynamic State: This exercise perfectly illustrates the difference between modelling structure and state.\n\nWithout the Token class: The diagram would only describe the static structure of the Petri Net graph (which places and transitions exist and how they are connected by arcs).\nWith the Token class: The model can now represent the dynamic state of the network at any given moment (i.e., the “marking” of the net). The number and location of tokens are what determine which transitions can be fired, allowing the model to represent the system’s behaviour over time.",
    "crumbs": [
      "<span class='chapter-number'>4</span>  <span class='chapter-title'>Practical Exercises: Class Diagrams</span>"
    ]
  },
  {
    "objectID": "05-practical-exercises-object-diagrams.html",
    "href": "05-practical-exercises-object-diagrams.html",
    "title": "5  Practical Exercises: Object Diagrams",
    "section": "",
    "text": "This chapter provides practical exercises to apply the concepts of UML Object Diagrams. The goal is to learn how to represent a specific, concrete situation (a “snapshot” of a system) using instances of classes from a given class diagram.\n\n\n5.0.1 Exercise 1: Petri Net\nProblem: Given the following class diagram for a Petri Net, model the specific state of the Petri Net shown in the image below as a UML Object Diagram.\n\n\n\nClass diagram for a Petri Net.\n\n\n\n\n\nThe specific state of a Petri Net to be modelled.\n\n\n\n\n\n\n\n\nClick to see the solution\n\n\n\n\n\n\n\n\nObject diagram solution for the Petri Net exercise.\n\n\nCorrection Details:\n\nInstances of Place and Transition: The solution correctly creates four named instances of the Place class (p1, p2, p3, p4) and two named instances of the Transition class (t1, t2). Each instance is given a label corresponding to its name in the diagram (e.g., \"P1\", \"T1\").\nInstances of Arc (Links): The seven arcs from the problem are modelled as seven distinct, named instances of the Arc class (a1 to a7). The source and destination links for each arc instance are correctly connected to the appropriate Place and Transition objects, modelling the directed graph structure.\nInstances of Token (State): The state of the Petri Net is represented by four instances of the Token class (tk1 to tk4).\n\np1 and p4 each contain one token.\np3 contains two tokens (tk2 and tk3).\nEach Token object is linked to the Place object that contains it via an instance of the se situe association.\n\nInstance of PetriNet: The entire system is contained within a single instance of PetriNet, named mon_petri. All Place, Transition, and Arc objects are linked to this main object, respecting the composition relationships defined in the class diagram.\n\n\n\n\n\n\n\n5.0.2 Exercise 2: Email Service\nProblem: Based on the class diagram modelling a university’s email service, create the object diagram that represents the specific email situation shown in the image below.\n\n\n\nClass diagram for a university email service.\n\n\n\n\n\nA screenshot of an email sent by Tony Leclercq.\n\n\n\n\n\n\n\n\nClick to see the solution\n\n\n\n\n\n\n\n\nObject diagram solution for the Email exercise.\n\n\nCorrection Details:\n\nInstances of m1: Mail: A single instance of the Mail class represents the email. Its slots are filled with the corresponding data: sujet = \"Email 1\" and objet = \"Hello World !\".\nInstances of pj1, pj2: PieceJointe: The two attachments, “AMSI.pdf” and “MAPLE2013.pdf”, are modelled as two distinct instances of the PieceJointe class. Both are linked to the m1 mail object via the possède (owns) composition link.\nInstances of c1, c2, c3, c4: Compte: The four email addresses involved are represented by four instances of the Compte (Account) class, with their adresseMail slots correctly filled.\n\nc3 and c4 represent the accounts of Tony Leclercq.\nc1 and c2 represent the external recipients.\n\nLinks for Senders/Recipients: The links correctly model the email’s flow:\n\nThe est envoyé par (is sent by) link connects m1 to c4 (Tony’s sending account).\nThe est destiné à (is sent to) links connect m1 to c1, c2, and c3 (the three recipient accounts).\n\nInstances of p1, p2: Personnel: Two instances of Personnel are used to model Tony Leclercq, who is both the sender and a recipient. This might seem redundant, but it correctly represents his dual role in this specific transaction. Both instances are linked to their respective Compte objects (c3 and c4).",
    "crumbs": [
      "<span class='chapter-number'>5</span>  <span class='chapter-title'>Practical Exercises: Object Diagrams</span>"
    ]
  },
  {
    "objectID": "06-ocl.html",
    "href": "06-ocl.html",
    "title": "6  The Object Constraint Language (OCL): An Overview",
    "section": "",
    "text": "6.1 The Need for Precision: What UML Diagrams Don’t Say\nThis chapter introduces the Object Constraint Language (OCL), a formal language used to add precise and unambiguous rules to UML models. We will explore why UML diagrams alone are often insufficient and how OCL helps to create more rigorous and verifiable software specifications.\nAs we have seen, UML diagrams, especially Class Diagrams, are powerful tools for modelling the static structure of a system. However, they cannot capture all the business rules and constraints that govern a system’s behaviour. A diagram can be syntactically correct but still allow for situations that are logically incorrect or violate business rules.\nConsider the following class diagram for a car rental system:\nThis diagram leaves many important questions unanswered:\nWhile we could add this information in natural language, this approach is notoriously unreliable. Natural language specifications are prone to what are often called the “7 Deadly Sins”:\nThese issues make automated verification impossible and lead to costly errors in implementation. To solve this, we need a formal, unambiguous way to express these rules, which is precisely the role of OCL.",
    "crumbs": [
      "<span class='chapter-number'>6</span>  <span class='chapter-title'>The Object Constraint Language (OCL): An Overview</span>"
    ]
  },
  {
    "objectID": "06-ocl.html#introduction-to-ocl",
    "href": "06-ocl.html#introduction-to-ocl",
    "title": "6  The Object Constraint Language (OCL): An Overview",
    "section": "6.2 Introduction to OCL",
    "text": "6.2 Introduction to OCL\nTo solve the problems of ambiguity and imprecision, the Object Constraint Language (OCL) was created. It is the official standard from the OMG (Object Management Group) for adding formal constraints to UML models.\nOCL is a declarative, textual, and formal language. This means:\n\nDeclarative: You specify what should be true, not how to check it.\nTextual: It integrates seamlessly with the graphical nature of UML diagrams.\nFormal: It has a well-defined mathematical foundation, which removes ambiguity.\n\nIt is designed to be a middle ground: more precise than natural language, but less complex and easier to learn than purely mathematical formalisms.\n\n6.2.1 Language Philosophy\nTo use OCL correctly, it is crucial to understand its core philosophy: OCL is a pure specification language, not a programming language. This has two major consequences:\n\n\n\n\n\n\nNo Side Effects\n\n\n\nAn OCL expression is a query that can only read the state of the model, it can never change it. You cannot use OCL to assign a value to an attribute, create an object, or call an operation that modifies the system’s state. This guarantees that checking a constraint will never alter the system you are verifying.\n\n\n\n\n\n\n\n\nInstantaneous Evaluation\n\n\n\nThe evaluation of an OCL expression is considered to be instantaneous. This is a powerful abstraction that means the state of the system is “frozen” during the evaluation of a constraint. You don’t have to worry about other parts of the system changing while your expression is being checked, which greatly simplifies writing complex rules.",
    "crumbs": [
      "<span class='chapter-number'>6</span>  <span class='chapter-title'>The Object Constraint Language (OCL): An Overview</span>"
    ]
  },
  {
    "objectID": "06-ocl.html#basic-ocl-concepts",
    "href": "06-ocl.html#basic-ocl-concepts",
    "title": "6  The Object Constraint Language (OCL): An Overview",
    "section": "6.5 Basic OCL Concepts",
    "text": "6.5 Basic OCL Concepts\nEvery OCL expression is written in the context of a specific element in the UML model (usually a class). This context defines the starting point for navigation. The keyword self is used to refer to the contextual instance.\nOCL is a typed language. Every expression has a type, which can be:\n\nPrimitive Types: Integer, Real, String, and Boolean.\nUML Types: Every class, interface, or enumeration in your UML model automatically becomes a type in OCL.\nCollection Types: OCL has powerful built-in types for handling collections of objects, such as Set(T), OrderedSet(T), Bag(T), and Sequence(T).\n\nIn the following sections, we will explore how to use these concepts to write meaningful constraints.",
    "crumbs": [
      "<span class='chapter-number'>6</span>  <span class='chapter-title'>The Object Constraint Language (OCL): An Overview</span>"
    ]
  },
  {
    "objectID": "06-ocl.html#the-need-for-precision-what-uml-diagrams-dont-say",
    "href": "06-ocl.html#the-need-for-precision-what-uml-diagrams-dont-say",
    "title": "6  The Object Constraint Language (OCL): An Overview",
    "section": "",
    "text": "A class diagram for a car rental system.\n\n\n\n\nCan a customer who is on the blacklist rent a new car?\nHow is the price of a rental calculated?\nCan the pickup and drop-off branches be different?\nShould a driver’s license be valid for the entire rental period?\n\n\n\n\n\n\n\n\nThe 7 Deadly Sins of Natural Language Specification\n\n\n\n\nAmbiguity: A statement can be interpreted in multiple ways.\nContradiction: Two or more rules in the specification conflict with each other.\nSilence (Incompleteness): A required rule or feature is not mentioned at all.\nNoise: The text contains irrelevant information that obscures the actual requirements.\nOver-specification: The text unnecessarily describes implementation details (“how”) instead of requirements (“what”).\nVagueness: The requirements are not stated precisely enough to be verified.\nWishful Thinking: A requirement is described that is impossible to implement.",
    "crumbs": [
      "<span class='chapter-number'>6</span>  <span class='chapter-title'>The Object Constraint Language (OCL): An Overview</span>"
    ]
  },
  {
    "objectID": "06-ocl.html#main-applications-of-ocl",
    "href": "06-ocl.html#main-applications-of-ocl",
    "title": "6  The Object Constraint Language (OCL): An Overview",
    "section": "6.3 Main Applications of OCL",
    "text": "6.3 Main Applications of OCL\nOCL is a versatile language used to add precision to a model in several key ways. Let’s explore its main applications with concrete examples based on our car rental system.\n\nConstraining Models (Invariants): The primary use of OCL is to write invariants. An invariant is a rule that must be true for all instances of a class at all times.\nExample: A customer’s discount must always be a positive value.\ncontext Customer inv:\n  self.discount &gt;= 0\nExplanation: This simple invariant ensures that for any Customer object, the discount attribute (which is an Integer in the diagram) can never be negative.\nSpecifying Contracts (Preconditions & Postconditions): OCL is used to define formal contracts for operations. A precondition must be true before an operation is executed, and a postcondition must be true after.\nExample: To extend a rental, its state must be ‘active’.\ncontext Rental::extendRental(newDate: Date)\n  pre must_be_active:\n    self.state = 'active'\nExplanation: This precondition checks that the state attribute of the Rental instance is equal to the string 'active'. The operation cannot be called otherwise.\nSpecifying Derived Values: OCL can define how the value of an attribute should be calculated from other information. This is for values that are not stored directly.\nExample: Let’s define a derived boolean attribute isPrivileged for a Customer.\ncontext Customer derive: isPrivileged: Boolean =\n  self.premium = true and self.discount &gt; 10\nExplanation: This rule states that a customer is considered “privileged” if and only if their premium status is true and their discount is greater than 10.\nDefining Queries: You can use OCL to navigate through the model to retrieve information, much like a query.\nExample: A query to get the set of all active rentals for a specific customer.\ncontext Customer\n  def: getActiveRentals(): Set(Rental) =\n    self.rental-&gt;select(r | r.state = 'active')\nExplanation: This defines a new operation getActiveRentals on the Customer class. It navigates to the customer’s collection of rental and uses the select iterator to return a new set containing only those rentals whose state is ‘active’.",
    "crumbs": [
      "<span class='chapter-number'>6</span>  <span class='chapter-title'>The Object Constraint Language (OCL): An Overview</span>"
    ]
  },
  {
    "objectID": "06-ocl.html#main-applications-of-ocl-1",
    "href": "06-ocl.html#main-applications-of-ocl-1",
    "title": "6  The Object Constraint Language (OCL): An Overview",
    "section": "6.4 Main Applications of OCL",
    "text": "6.4 Main Applications of OCL\nOCL is a versatile language used to add precision to a model in several key ways. Let’s explore its main applications with concrete examples based on our car rental system.\n\nConstraining Models (Invariants): The primary use of OCL is to write invariants. An invariant is a rule that must be true for all instances of a class at all times. It defines a condition that cannot be violated.\nExample: A customer who is blacklisted cannot have any rentals with an ‘active’ state.\ncontext Customer inv blacklisted_cannot_have_active_rentals:\n  self.oclIsTypeOf(BlackListed) implies \n    self.rental-&gt;select(r | r.state = 'active')-&gt;isEmpty()\nExplanation:\n\nself.oclIsTypeOf(BlackListed): This is the key part. When the context is Customer, this expression checks if the specific instance (self) is of the type BlackListed.\nself.rental-&gt;select(r | r.state = 'active'): This navigates to the customer’s rentals and selects only those whose state attribute is ‘active’.\n-&gt;isEmpty(): L’invariant est respecté si cette collection de locations actives est vide.\n\nSpecifying Contracts (Preconditions & Postconditions): OCL is used to define formal contracts for operations, ensuring they behave as expected.\n\nA precondition is a condition that must be true before an operation is executed.\nA postcondition is a condition that must be true after an operation has successfully completed.\n\nExample: An operation to add a new car to a rental agreement. The precondition is that the car must be available. The postcondition is that the number of cars in the group has increased by one.\ncontext AssignedCarGroup::addCar(c: Car)\n  pre car_must_be_available:\n    c.rental-&gt;isEmpty()\n  post number_of_cars_increased:\n    self.car-&gt;size() = self.car@pre-&gt;size() + 1\n  post car_is_added:\n    self.car-&gt;includes(c)\nExplanation:\n\npre car_must_be_available: This precondition navigates from the Car object c to its associated rentals. It checks that this collection of rentals is empty, ensuring the car isn’t already assigned to another rental.\npost number_of_cars_increased: This is a classic and robust postcondition. It uses @pre to compare the size of the car collection after the operation with its size before the operation, guaranteeing that exactly one car was added.\npost car_is_added: This postcondition provides an additional guarantee: the specific car c passed as a parameter is now included in the car collection of the AssignedCarGroup.\n\nSpecifying Derived Values: OCL can define how the value of an attribute or an association end should be calculated from other information in the model. This is useful for values that are not stored directly but are computed on the fly.\nExample: The price of a rental is derived from the quote’s value minus a discount.\ncontext Rental derive: price: Real =\n  self.rentalAgreement.value * (1 - self.discount/100.0)\nDefining Queries: You can use OCL to navigate through the model’s associations to retrieve information, much like using SQL on a database. An OCL expression can act as a query returning a value or a collection of objects.\nExample: A query to get the set of all cars rented by a specific customer.\ncontext Customer\n  def: allRentedCars(): Set(Car) =\n    self.rental.assignedCar.car",
    "crumbs": [
      "<span class='chapter-number'>6</span>  <span class='chapter-title'>The Object Constraint Language (OCL): An Overview</span>"
    ]
  },
  {
    "objectID": "06-ocl.html#fundamental-ocl-concepts",
    "href": "06-ocl.html#fundamental-ocl-concepts",
    "title": "6  The Object Constraint Language (OCL): An Overview",
    "section": "6.4 Fundamental OCL Concepts",
    "text": "6.4 Fundamental OCL Concepts\nTo write meaningful constraints, we first need to understand the two pillars of the OCL language: its robust typing system, and its precise syntax and the formal semantics that underpin it.\n\n6.4.1 OCL is a Typed Language\nEvery element in OCL, from an attribute to the result of a complex navigation, has a type. This strong typing system ensures that expressions are well-formed and prevents errors, much like in languages like Java. OCL’s type system is built from three sources:\n\n6.4.1.1 Primitive Types\nOCL includes four fundamental, built-in types that are the basis for most expressions:\n\nInteger (e.g., 5, -10)\nReal (e.g., 3.14, -0.5)\nString (e.g., 'active', 'John Doe')\nBoolean (true, false)\n\n\n\n6.4.1.2 UML Model Types\nThis is a powerful feature: every classifier you define in your UML model automatically becomes a new type in OCL. If you have a class named Customer in your diagram, Customer becomes a valid type in your OCL expressions. This allows you to write constraints that are perfectly tailored to your specific domain.\n\n\n6.4.1.3 Collection Types\nBecause navigating associations often results in multiple objects, OCL has a rich set of built-in collection types to handle them. The collection is an abstract type with four concrete subtypes:\n\n\n\n\n\n\n\n\n\nCollection Type\nOrder Matters?\nDuplicates Allowed?\nExample Literal\n\n\n\n\nSet(T)\nNo\nNo\nSet{1, 2, 3}\n\n\nOrderedSet(T)\nYes\nNo\nOrderedSet{1, 2, 3}\n\n\nBag(T)\nNo\nYes\nBag{1, 2, 2, 3}\n\n\nSequence(T)\nYes\nYes\nSequence{1, 3, 2, 3}\n\n\n\nBy default, navigating a * multiplicity association returns a Set. Understanding these collection types is essential, as most non-trivial OCL expressions involve manipulating collections.\n\n\n\n6.4.2 Special OCL Types\nBeyond the primitive and model-based types, OCL provides a set of special, built-in classifiers that are essential for writing advanced constraints. The hierarchy of these types is shown in the diagram below.\n\n\n\nA class diagram showing the OCL Type Hierarchy, with Classifier at the top.\n\n\nLet’s explore the most important ones:\n\nOclAny: This is the supertype of all other types in OCL (except for collection and tuple types). Any operation defined on OclAny (like oclIsTypeOf()) is available on all objects in your model.\nOclVoid: This type has only one possible value: null. It is used to check if a property has been set or not. Any expression that results in a division by zero, for example, will evaluate to null. You can check for this value using the oclIsUndefined() operation.\nOclInvalid: This type has only one value: invalid. It is used to represent the result of an ill-formed expression, for instance, when trying to navigate from null. It is a subtype of all other types, meaning an invalid value can “poison” an entire expression. You can check for it with oclIsInvalid().\nTupleType: A tuple is a structured type that groups together several named parts, each with its own type. It’s similar to a struct or a record and is very useful for returning multiple values from a query operation.\nTuple{name: String = 'Mikel', id: Integer = 123}\nOclState: This special type is used exclusively within state machine diagrams. The operation oclIsInState(stateName: OclState) allows you to write a constraint that checks if an object is currently in a specific state, which is very powerful for defining state-dependent invariants.\nOclMessage: Used in interaction diagrams (like sequence diagrams), this type allows you to write constraints on the messages exchanged between objects. For example, you can check if a specific message has been sent or received.\n\n\n\n6.4.3 Type Conformance and Subtyping\nThe OCL type system is not flat, it has a rich hierarchy that defines which types are considered subtypes of others. This is known as type conformance. Understanding these rules is crucial, as it determines when a value of one type can be used where a value of another type is expected.\nThe main rules of type conformance in OCL are as follows:\n\nFor primitive numbers, the hierarchy is logical: UnlimitedNatural is a subtype of Integer, which is a subtype of Real.\nOclAny is the ultimate supertype for all non-collection types. This means any object from your UML model is conformant to OclAny.\nThe hierarchy of your UML model types mirrors the generalization (inheritance) relationships in your class diagram. If you have a Student class that inherits from Person, then Student is a subtype of Person in OCL.\nFor collections, Set(T), Bag(T), Sequence(T), and OrderedSet(T) are all subtypes of the general Collection(T) type.\nThe special types have their own rules:\n\nOclVoid (representing null) is a subtype of all other types (except OclInvalid).\nOclInvalid is the ultimate subtype, it is a subtype of every other type. This explains why an invalid value can propagate through and “poison” any expression.\n\n\nThis hierarchy is visualized in the diagram below.\n\n\n\nA class diagram showing the OCL Type Hierarchy and a list of the 7 conformance rules.\n\n\n\n\n6.4.4 Standard OCL Operators\nLike any language, OCL comes with a standard set of operators to perform logical, relational, and arithmetic operations. These are the building blocks for creating complex boolean expressions within your constraints.\n\n6.4.4.1 Logical Operators\nOCL supports the standard boolean logic operators. Note that they are written in lowercase.\n\n\n\n\n\n\n\n\nOperator\nSyntax\nDescription\n\n\n\n\nand\na and b\nTrue if both a and b are true.\n\n\nor\na or b\nTrue if either a or b is true.\n\n\nxor\na xor b\nTrue if exactly one of a or b is true.\n\n\nnot\nnot a\nTrue if a is false.\n\n\nimplies\na implies b\nFalse only if a is true and b is false.\n\n\n\nExample: A premium customer must have a discount.\ncontext Customer inv:\n  self.premium implies (self.discount &gt; 0)\n\n6.4.4.1.1 The if-then-else Expression\nUnlike in many programming languages, if in OCL is not a statement but an expression that always returns a value.\ncontext Customer\n  def: customerCategory: String =\n    if self.premium then\n      'High Value'\n    else\n      'Standard'\n    endif\n\n\n\n\n\n\nImportant Rules for if expressions\n\n\n\n\nThe else clause is mandatory. Since if is an expression, it must always result in a value, so the else part can never be omitted.\nType Conformance. The type of the if expression is the most specific common supertype of the then expression and the else expression.\n\n\n\n\n\n6.4.4.1.2 A Note on Evaluation\nOCL has a very specific rule for evaluating boolean expressions that differs from many common programming languages.\n\n\n\n\n\n\nNo Short-Circuit Evaluation\n\n\n\nThe logical operators and, or, and xor in OCL are strict. This means that both operands are always evaluated, even if the result of the first operand is enough to determine the outcome. There is no “short-circuit” or “lazy” evaluation. This is a common source of errors, especially when dealing with potentially null values.\n\n\n\n\n\n6.4.4.2 Relational, Arithmetic, and String Operators\nOCL provides a rich set of standard operators for the primitive types, allowing for the construction of detailed and precise expressions.\n\n6.4.4.2.1 Relational Operators\nThese operators are used for comparison and work across most primitive types to produce a Boolean result.\n\n\n\nOperator\nDescription\n\n\n\n\n=\nEquality\n\n\n&lt;&gt;\nInequality (not equal)\n\n\n&lt;\nLess than\n\n\n&gt;\nGreater than\n\n\n&lt;=\nLess than or equal to\n\n\n&gt;=\nGreater than or equal to\n\n\n\n\n\n6.4.4.2.2 Arithmetic Operators for (Integer and Real)\nOCL provides a standard library of arithmetic functions for numerical types.\n\n\n\n\n\n\n\nOperator\nDescription\n\n\n\n\n+, -, *, /\nAddition, Subtraction, Multiplication, Division\n\n\nabs()\nAbsolute value\n\n\nfloor(), round()\nFloor and Rounding functions\n\n\nmax(n), min(n)\nThe maximum or minimum of two numbers\n\n\nmod(n)\nModulo operation\n\n\n\n\n\n6.4.4.2.3 Operators for Strings (String)\nOCL includes a powerful set of operations for manipulating strings.\n\n\n\n\n\n\n\n\nOperation\nDescription\nExample\n\n\n\n\nsize()\nReturns the number of characters in the string.\n'hello'.size() = 5\n\n\nconcat(s2)\nConcatenates another string s2.\n'hello'.concat(' world') results in 'hello world'\n\n\ntoUpper()\nConverts the string to uppercase.\n'hello'.toUpper() results in 'HELLO'\n\n\ntoLower()\nConverts the string to lowercase.\n'HELLO'.toLower() results in 'hello'\n\n\nsubstring(i1, i2)\nReturns the substring from index i1 to i2.\n'hello'.substring(2, 4) results in 'ell'\n\n\n\nExample: An invariant stating that a car group’s category must be a single uppercase letter.\ncontext CarGroup inv:\n  self.category.size() = 1 and self.category = self.category.toUpper()\n\n\n\n6.4.4.3 Operator Precedence\nOCL defines a strict order of precedence to determine how complex expressions are evaluated. The following table lists the operators in decreasing order of priority, from highest (evaluated first) to lowest (evaluated last).\n\n\n\nPriority\nOperator(s)\nDescription\n\n\n\n\n1 (Highest)\n@pre\nTime marker (used in post-conditions)\n\n\n2\n. , -&gt;\nNavigation (dot and arrow)\n\n\n3\nnot , -\nUnary operators (negation)\n\n\n4\n* , /\nMultiplication, Division\n\n\n5\n+ , -\nAddition, Subtraction (binary)\n\n\n6\nif-then-else-endif\nConditional expression\n\n\n7\n= , &lt;&gt; , &gt; , &lt; , &gt;= , &lt;=\nRelational operators\n\n\n8\nand , or , xor\nLogical operators\n\n\n9\nimplies\nLogical implication\n\n\n10 (Lowest)\nin\n(Not covered yet)\n\n\n\n\n\n\n\n\n\nBest Practice: Use Parentheses\n\n\n\nEven if you know the precedence rules, it is always a good practice to use parentheses () to make your expressions explicit and easier to read. This avoids any ambiguity for you and for others who will read your model.\n\n\n\n\n\n6.4.5 The context and self Keywords\nEvery OCL constraint is anchored to a specific element in the UML model. The context keyword declares this anchor, defining the perspective from which the OCL expression will be evaluated. Within this context, the keyword self always refers to the specific instance of the element being constrained.\nOCL defines three primary types of context:\n\n6.4.5.1 Classifier Context\nThis is the most common context, used for defining invariants. The context is a classifier, typically a class, and self refers to an instance of that class.\nSyntax: context &lt;ClassName&gt;\ncontext Customer inv:\n  self.discount &gt;= 0\n\n\n6.4.5.2 Operation Context\nThis context is used to define preconditions and postconditions for an operation. The context is a specific operation within a class, and self refers to the instance of the class on which the operation is being called.\nSyntax: context &lt;ClassName&gt;::&lt;operationName&gt;(...)\ncontext Rental::extendRental(newDate: Date)\n  pre: self.state = 'active'\n\n\n6.4.5.3 3. Attribute Context\nThis context is used to define constraints on an attribute, typically for derived values or initial values. The context is a specific attribute within a class, and self refers to the instance of the class that owns the attribute.\nSyntax: context &lt;ClassName&gt;::&lt;attributeName&gt;: &lt;Type&gt;\ncontext Customer::isPrivileged: Boolean\n  derive: self.premium = true and self.discount &gt; 10\n\n\n\n6.4.6 Writing Constraints: Invariants\nThe most common type of constraint you will write in OCL is the invariant.\n\n\n\n\n\n\nWhat is an Invariant?\n\n\n\nAn invariant is a constraint that must be true for all instances of a class at all times during the system’s execution. It defines a condition of integrity that can never be violated. If an operation causes an invariant to become false, the system is considered to be in an invalid state.\n\n\n\n6.4.6.1 Syntax\nThe general syntax for an invariant is straightforward:\ncontext &lt;Classifier&gt; inv []:   &lt;boolean_expression&gt;\n\ncontext &lt;Classifier&gt;: Specifies the class to which the invariant applies.\ninv: The stereotype indicating this is an invariant.\n[&lt;constraint_name&gt;]: An optional but highly recommended name for the constraint.\n&lt;boolean_expression&gt;: The OCL expression that must always evaluate to true.\n\n\n\n6.4.6.2 Invariant Examples\nLet’s illustrate with a few examples based on our car rental system.\n\n6.4.6.2.1 Example 1: Simple Attribute Constraint\nA very common use for invariants is to restrict the possible values of an attribute.\n\nRule: A customer’s discount must be a positive value.\n\ncontext Customer inv:\n  self.discount &gt;= 0\n\n\n6.4.6.2.2 Example 2: Constraint Across an Association\nInvariants are powerful for defining rules that involve multiple, associated classes.\n\nRule: A car that is currently assigned to an active rental cannot be part of a CarGroup marked as ‘in_maintenance’.\n\ncontext Car inv:\n  self.rental-&gt;exists(r | r.state = 'active') implies \n    self.carGroup.category &lt;&gt; 'in_maintenance'\n\n\n6.4.6.2.3 Example 3: Constraint with Inheritance\nInvariants can also enforce rules related to a class hierarchy.\n\nRule: A customer who is on the blacklist (i.e., is of type BlackListed) cannot have any active rentals.\n\ncontext Customer inv:\n  self.oclIsTypeOf(BlackListed) implies\n    self.rental-&gt;select(r | r.state = 'active')-&gt;isEmpty()\n\n\n\n\n6.4.7 Writing Contracts: Preconditions and Postconditions\nWhile invariants define the rules for a class’s state, preconditions and postconditions define a contract for its operations. They specify what an operation requires to run and what it guarantees to accomplish.\n\n\n\n\n\n\nWhat are Preconditions and Postconditions?\n\n\n\n\nA precondition is a constraint that must be true before an operation is executed. It is the responsibility of the caller to satisfy the precondition. If it’s false, the operation should not be called.\nA postcondition is a constraint that must be true after an operation has successfully completed. It is the responsibility of the operation itself to establish the postcondition.\n\n\n\n\n6.4.7.1 Syntax\nThe syntax is similar to invariants, but the context is an operation, and the stereotypes are pre and post.\ncontext &lt;Classifier&gt;::&lt;operationName&gt;(...)   pre []: &lt;boolean_expression&gt;   post []: &lt;boolean_expression&gt;\n\n6.4.7.1.1 Precondition Example\nA precondition specifies the conditions under which an operation can be legally called.\n\nRule: A customer can only be added to the blacklist if they are not already on it.\n\ncontext Customer::addToBlackList(d: Date)\n  pre is_not_already_blacklisted:\n    self.oclIsTypeOf(BlackListed) = false\nExplanation: This contract states that before calling addToBlackList on a Customer object, that object must not already be of the type BlackListed.\n\n\n6.4.7.1.2 Postcondition Example and the @pre Keyword\nA postcondition specifies the state of the system after the operation has finished. A crucial tool for this is the @pre keyword, which allows you to refer to a value as it was before the operation started.\n\nRule: After a customer is successfully added to the blacklist, they must be of the type BlackListed.\n\ncontext Customer::addToBlackList(d: Date)\n  post is_now_blacklisted:\n    self.oclIsTypeOf(BlackListed) = true\nHere’s a more complex example using @pre:\n\nRule: After a rental is extended, the new end date must be the one provided, and the number of associated cars must not have changed.\n\ncontext Rental::extendRental(newDate: Date)\n  post end_date_is_updated:\n    self.endingDate = newDate\n  post number_of_cars_is_unchanged:\n    self.assignedCar-&gt;size() = self.assignedCar@pre-&gt;size()\nExplanation:\n\nThe first postcondition checks the new value of endingDate.\nThe second postcondition is critical: it uses self.assignedCar@pre to refer to the collection of cars before the operation ran and ensures its size has not changed. This prevents unintended side effects.\n\n\n\n\n\n6.4.8 Initial and Derived Values, Query and Body Definitions\nBeyond invariants and contracts, OCL can be used to precisely define how attributes and operations get their values.\n\n6.4.8.1 init: Specifying Initial Values\nThe init stereotype allows you to define a constraint for the initial value of an attribute when an object is created. This is more powerful than a simple default value because you can use a complex OCL expression.\nSyntax: context &lt;ClassName&gt;::&lt;attributeName&gt;: &lt;Type&gt; init: &lt;expression&gt;\nExample: When a Rental object is created, its state is initialized to ‘planned’.\ncontext Rental::state: String\n  init: 'planned'\n\n\n6.4.8.2 derive: Specifying Derived Values\nThe derive stereotype is used for attributes whose value is not stored but is always calculated based on other properties of the model. This is used for derived attributes, which are often denoted with a / in front of their name in a class diagram.\nSyntax: context &lt;ClassName&gt;::&lt;attributeName&gt;: &lt;Type&gt; derive: &lt;expression&gt;\nExample: A customer is considered “privileged” if they are premium and have a discount greater than 10.\ncontext Customer::isPrivileged: Boolean\n  derive: self.premium = true and self.discount &gt; 10\n\n\n6.4.8.3 def: Defining Query Operations\nThe def stereotype allows you to define the body of a query operation directly in OCL. This is useful for specifying operations that retrieve information without changing the system’s state.\nSyntax: context &lt;ClassName&gt; def: &lt;operationName&gt;(): &lt;ReturnType&gt; = &lt;expression&gt;\nExample: Defining an operation that returns the set of all active rentals for a customer.\ncontext Customer\n  def: getActiveRentals(): Set(Rental) =\n    self.rental-&gt;select(r | r.state = 'active')\n\n\n6.4.8.4 body: Defining Operation Bodies\nWhile def is used to define a new query operation not present in the UML model, the body stereotype is used to provide a concrete implementation for an operation that is already declared in a class diagram.\nThis is particularly useful when you want to formally specify the result of a query operation without leaving its logic ambiguous.\nSyntax: context &lt;ClassName&gt;::&lt;operationName&gt;(): &lt;ReturnType&gt; body: &lt;expression&gt;\nExample: Defining the body for a getDiscountedPrice() operation on the Rental class.\ncontext Rental::getDiscountedPrice(): Real\n  body: self.price * (1 - self.customer.discount/100.0)\nExplanation: This OCL constraint provides the implementation for the getDiscountedPrice() operation. It specifies that the returned Real value is calculated by taking the rental’s base price and applying the discount associated with the customer. Any programming language implementation of this class would now have a formal specification to follow for this method.\n\n\n\n6.4.9 Navigating the Model\nThe primary power of OCL comes from its ability to navigate through a class diagram, starting from a context instance (self) to access its attributes, call its operations, and traverse its associations to reach other objects.\n\n6.4.9.1 Accessing Properties and Traversing Associations\nNavigation is performed using the dot (.) notation.\n\nAccessing Attributes: self.age\nCalling Operations: self.getAge() (Note: operations must be query-only and have no side effects).\nTraversing an Association: To navigate, you use the role name at the opposite end of the association. If the role is unnamed, you use the name of the class itself, starting with a lowercase letter.\n\n\n\n\nA diagram showing a Person class associated with a Company class.\n\n\ncontext Person inv:\n  -- Navigates from Person to Company via the 'employer' role.\n  -- The result is a single object of type Company.\n  self.employer\n\n\n6.4.9.2 Navigation From a Collection\nThis is a fundamental concept in OCL. When you start a navigation from an expression that results in a collection, the navigation is performed on each element of that collection. The final result is a new collection containing all the individual results.\n\n\n\nA diagram showing navigation from an Administration object to a collection of Person objects.\n\n\ncontext Administration inv:\n  -- 1. self.persons returns a Set of Person objects: Set{p1, p2}\n  self.persons\n\n  -- 2. Navigating to 'name' from this Set returns a Bag of all names.\n  -- The result is Bag{'jack', 'lisa'}\n  self.persons.name\n\n  -- 3. Navigating to 'age' returns a Bag of all ages.\n  -- The result is Bag{30, 22}\n  self.persons.age\nNote: When you navigate from a Set to an attribute, the result is a Bag, not a Set, because different objects in the original set could have the same value for that attribute.\n\n\n6.4.9.3 Chained Navigation\nYou can chain navigations together to traverse complex paths in your model. The rules of collection navigation apply at each step.\n\n\n\nA diagram showing chained navigation from Rental to AssignedCar, then CarGroup, then category.\n\n\ncontext Administration inv:\n  -- self.persons -&gt; Set{p1, p2}\n  -- self.persons.children returns a Bag containing all children of p1 and p2.\n  self.persons.children\n\n  -- This expression first gets all children (a Bag),\n  -- then for each child, it navigates to their parents (a Set of 2 Persons).\n  -- The final result is a Bag containing all the parents of all the children.\n  self.persons.children.parent\n\n6.4.9.3.1 A Note on Flattening Collections\nWhen a navigation path involves multiple “to-many” associations, OCL automatically simplifies the result.\nConsider the expression from the slide:\ncontext Administration inv:\n  self.persons.car\nLet’s break this down:\n\nself.persons returns a Set of Person objects.\nFor each Person in that set, .car returns a Set of Car objects (because the multiplicity is *).\nThe result is therefore a collection of collections, for example: Bag{ Set{car1}, Set{car2, car3} }.\n\nInstead of forcing you to work with this complex nested structure, OCL automatically flattens it into a single Bag containing all the elements: Bag{car1, car2, car3}.\nThis is why you can continue the navigation chain directly. The expression self.persons.car.type works as follows:\n\nself.persons.car produces a flattened Bag of all cars owned by all persons.\nThe navigation .type is then applied to each Car in this flattened bag.\nThe final result is a Bag of all the type strings from all those cars.\n\n\n\n\n\n6.4.10 Working with Collections\nBecause navigation often results in collections, OCL provides a rich set of predefined operations to query and manipulate them. These operations are always invoked using the arrow (-&gt;) notation.\n\n6.4.10.1 Basic Operations\nThese operations provide fundamental information about a collection or check for the presence of specific elements.\n\nsize(): Returns the number of elements.\nisEmpty() / notEmpty(): Checks if the collection is empty or not.\nincludes(obj) / excludes(obj): Checks if a specific object is in the collection.\nincludesAll(coll2) / excludesAll(coll2): Checks if all (or no) elements of another collection coll2 are present.\ncount(obj): Counts the occurrences of an object in the collection (most useful for Bag and Sequence).\n\nExample: An invariant stating that a Person must have exactly two parents.\ncontext Person inv:\n  self.parent-&gt;size() = 2\n\n\n6.4.10.2 Iterators: The Power of Collections\nThe most powerful feature of OCL collections is the ability to use iterators. An iterator is an operation that evaluates an expression for each element in a collection, allowing you to filter, transform, or verify its properties.\n\n6.4.10.2.1 select and reject (Filtering)\nThese are the primary tools for filtering a collection. They return a new collection containing only the elements that satisfy (or don’t satisfy) a condition.\n\nselect(v | boolean_expression): Returns a sub-collection with elements for which the expression is true.\nreject(v | boolean_expression): Returns a sub-collection with elements for which the expression is false.\n\nExample: Select all rentals for a customer that are currently active.\ncontext Customer\n  def: getActiveRentals(): Set(Rental) =\n    self.rental-&gt;select(r | r.state = 'active')\n\n\n6.4.10.2.2 forAll and exists (Quantifiers)\nThese iterators evaluate a condition over a collection and return a single Boolean value. They are essential for writing precise invariants.\n\nforAll(v | boolean_expression): Returns true if the expression is true for all elements.\nexists(v | boolean_expression): Returns true if the expression is true for at least one element.\n\nExample: An invariant stating that all cars in a “Luxury” car group must be of the brand “Mercedes”.\ncontext CarGroup inv:\n  self.category = 'Luxury' implies\n    self.car-&gt;forAll(c | c.brand = 'Mercedes')\n\n\n6.4.10.2.3 collect (Transformation)\nThe collect iterator transforms a collection by applying an expression to each of its elements. It returns a new Bag containing the results (similar to a map function).\nExample: Get a collection of all the registration numbers of the cars rented by a customer.\ncontext Customer\n  def: allRentedCarRegNums(): Bag(String) =\n    self.rental.assignedCar.car-&gt;collect(c | c.regNum)\n\n\n\n6.4.10.3 closure (Transitive Closure)\nThe closure iterator is an advanced and extremely powerful operation that calculates the transitive closure of a relationship over a collection. In simpler terms, it allows you to repeatedly navigate through an association until no more new elements can be discovered.\nThis is the perfect tool for working with hierarchical or graph-like structures, such as finding all descendants of a person in a family tree or all sub-parts in an assembly.\nSyntax: collection-&gt;closure( v | navigation_expression )\nExample: Find all descendants of a person (their children, their children’s children, and so on).\n\n\n\nA class diagram showing a reflexive ‘children’ association on the Person class.\n\n\ncontext Person\n  def: getAllDescendants(): Set(Person) =\n    self.children-&gt;closure(p | p.children)\nExplanation:\n\nself.children: The expression starts with the set of the person’s direct children.\n-&gt;closure(p | p.children): The closure iterator then takes each person p from that set, finds their own children, adds them to the result, and repeats this process until no new descendants can be found. The final result is a flattened Set containing all descendants at every level.\n\n\n\n\n6.4.11 Operations on All Objects (OclAny)\nBecause OclAny is the supertype of all types in your model, the operations it defines are available on every object. These are fundamental tools for checking equality, types, and for casting.\n\n6.4.11.1 Equality (= and &lt;&gt;)\nThese operators check if two expressions refer to the exact same object instance.\n\na = b: Returns true if a and b are the same object.\na &lt;&gt; b: Returns true if a and b are different objects.\n\n\n\n6.4.11.2 Type Checking: oclIsTypeOf vs. oclIsKindOf\nThese two operations are crucial for writing constraints in a generalization hierarchy, but they have a very important semantic difference.\n\noclIsTypeOf(Type): Returns true only if the object is an instance of that exact type, and not a subtype.\noclIsKindOf(Type): Returns true if the object is an instance of that type or any of its subtypes.\n\nLet’s consider the following hierarchy:\n\n\n\nA generalization hierarchy showing Student and Professor inheriting from Person.\n\n\nThe following examples illustrate the difference:\ncontext Person inv:\n  self.oclIsKindOf(Person)   -- returns true\n  self.oclIsTypeOf(Person)   -- returns true\n  self.oclIsKindOf(Student)  -- returns false\n  self.oclIsTypeOf(Student)  -- returns true\ncontext Student inv:\n  self.oclIsKindOf(Person)   -- returns true\n  self.oclIsTypeOf(Person)   -- returns false\n  self.oclIsKindOf(Student)  -- returns true\n  self.oclIsTypeOf(Student)  -- returns true\n  self.oclIsKindOf(Professor)-- returns false\n  self.oclIsTypeOf(Professor)-- returns false\n\n\n6.4.11.3 Type Casting: oclAsType\nThis operation allows you to cast an object to a more specific subtype. This is necessary when you need to access attributes or operations that are only defined on that subtype.\n\noclAsType(Type): Casts the object to the specified Type. If the object is not actually of that type or one of its subtypes, the expression result is invalid.\n\nExample: An invariant on a Person object, stating that if that person is a Student, their student ID must not be empty.\ncontext Person inv:\n  self.oclIsKindOf(Student) implies\n    self.oclAsType(Student).studentId-&gt;notEmpty()\nExplanation: We first check if the Person is a Student (or a subtype). If so, we cast self to Student to be able to safely access the studentId attribute.\n\n\n6.4.11.4 Handling Undefined Values (OclVoid)\nIn OCL, the value null has a specific type: OclVoid. It is used to represent an object that does not exist or an attribute that has not been set.\n\noclIsUndefined(): Returns true if the object is null.\noclIsInvalid(): Returns true if an expression is ill-formed (e.g., navigating from null).\n\nExample: An invariant stating that every Rental must be associated with a Customer (i.e., the driver role cannot be empty).\ncontext Rental inv:\n  self.driver.oclIsUndefined() = false\nThis is a robust way to check that a mandatory association (1..*) is respected.\n\n\n\n\n6.4.12 Special Operations: allInstances and oclIsNew\nTo conclude our overview of OCL, let’s look at two special operations that operate at a meta-level: one that queries all objects of a certain type, and another that checks for an object’s creation within a postcondition.\n\n6.4.12.1 allInstances(): Accessing All Objects of a Type\nThe allInstances() operation is unique because it is called directly on a class, not on an instance (self). It returns a Set containing all instances of that specific class that currently exist in the system at the time of evaluation.\nSyntax: &lt;ClassName&gt;.allInstances()\nThis operation is extremely powerful for writing global invariants that must hold true across the entire system.\nExample: An invariant to enforce that every employee in the system has a unique employee ID.\ncontext Employee inv:\n  Employee.allInstances()-&gt;forAll(e1, e2 | \n    e1 &lt;&gt; e2 implies e1.employeeId &lt;&gt; e2.employeeId\n  )\n\n\n\n\n\n\nUse with Caution\n\n\n\nThe allInstances() operation can be computationally expensive and conceptually dangerous. Using it on a type with a potentially huge or even infinite number of instances (like Integer or String) can lead to problems. It is best reserved for application-specific classes where the number of instances is manageable.\n\n\n\n\n6.4.12.2 oclIsNew(): Checking Object Creation\nThe oclIsNew() operation is a special tool used only in postconditions. It returns true if the object on which it is called was created during the execution of the operation specified in the context.\nExample: A postcondition for a createRental(...) operation on the Customer class, stating that a new Rental object has been created and is now linked to the customer.\ncontext Customer::createRental(...)\n  post: let newRental : Rental = self.rental-&gt;select(r | r.oclIsNew())-&gt;asSequence()-&gt;first() in\n    newRental.oclIsUndefined() = false and newRental.customer = self\nExplanation: This advanced postcondition first finds the new Rental object created during the operation using oclIsNew() and then asserts that this new rental exists and is correctly associated with the current customer (self).",
    "crumbs": [
      "<span class='chapter-number'>6</span>  <span class='chapter-title'>The Object Constraint Language (OCL): An Overview</span>"
    ]
  },
  {
    "objectID": "06-ocl.html#writing-constraints-invariants",
    "href": "06-ocl.html#writing-constraints-invariants",
    "title": "6  The Object Constraint Language (OCL): An Overview",
    "section": "6.5 Writing Constraints: Invariants",
    "text": "6.5 Writing Constraints: Invariants\nThe most common type of constraint you will write in OCL is the invariant.\n\n\n\n\n\n\nWhat is an Invariant?\n\n\n\nAn invariant is a constraint that must be true for all instances of a class at all times during the system’s execution. It defines a condition of integrity that can never be violated. If an operation causes an invariant to become false, the system is considered to be in an invalid state.\n\n\n\n6.5.0.1 Syntax\nThe general syntax for an invariant is straightforward:\ncontext &lt;Classifier&gt; inv []:   &lt;boolean_expression&gt;\n\ncontext &lt;Classifier&gt;: Specifies the class to which the invariant applies.\ninv: The stereotype indicating this is an invariant.\n[&lt;constraint_name&gt;]: An optional but highly recommended name for the constraint.\n&lt;boolean_expression&gt;: The OCL expression that must always evaluate to true.\n\n\n\n6.5.1 Invariant Examples\nLet’s illustrate with a few examples based on our car rental system.\n\n6.5.1.1 Example 1: Simple Attribute Constraint\nA very common use for invariants is to restrict the possible values of an attribute.\n\nRule: A customer’s discount must be a positive value.\n\ncontext Customer inv:\n  self.discount &gt;= 0\n\n\n6.5.1.2 Example 2: Constraint Across an Association\nInvariants are powerful for defining rules that involve multiple, associated classes.\n\nRule: A car that is currently assigned to an active rental cannot be part of a CarGroup marked as ‘in_maintenance’.\n\ncontext Car inv:\n  self.rental-&gt;exists(r | r.state = 'active') implies \n    self.carGroup.category &lt;&gt; 'in_maintenance'",
    "crumbs": [
      "<span class='chapter-number'>6</span>  <span class='chapter-title'>The Object Constraint Language (OCL): An Overview</span>"
    ]
  },
  {
    "objectID": "07-practical-exercises-ocl.html",
    "href": "07-practical-exercises-ocl.html",
    "title": "7  Practical Exercises: OCL Constraints",
    "section": "",
    "text": "This chapter provides a series of practical exercises to apply the concepts of the Object Constraint Language (OCL) to UML Class Diagrams. Each exercise presents a problem description and a UML model, followed by a detailed solution explaining the OCL constraints used to enforce the business rules.\n\n7.0.1 Exercise 1: Uniqueness of an Identifier\nProblem: Using the diagram for people and cars, write an OCL constraint to guarantee that each person has a unique identification number (num) across all instances of the Personne class[cite: 24].\n\n\n\n\n\n\nClick to see the solution\n\n\n\n\n\n\n\n\nUML diagram for the People and Cars exercise.\n\n\nCorrection Details:\nThe goal is to ensure that the num attribute is unique for every person in the system[cite: 28]. In OCL, this can be expressed in two equivalent ways[cite: 29].\n\nFormulation 1: Using isUnique() [cite: 30] This is the most direct and readable way to express the constraint. The isUnique() operation checks if a given property is unique for all elements in a collection.\ncontext Personne inv pKeyPersonne:\n  Personne.allInstances()-&gt;isUnique(num)\n\nExplanation: This invariant states that for the entire collection of Personne.allInstances(), the value of the num attribute must be unique for each instance[cite: 32].\n\nFormulation 2: Using forAll() [cite: 34] This formulation uses the universal quantifier forAll() to express the same logic by comparing every pair of Personne instances.\ncontext Personne inv pKeyPersonne:\n  Personne.allInstances()-&gt;forAll(p1, p2 | \n    p1 &lt;&gt; p2 implies p1.num &lt;&gt; p2.num\n  )\n\nExplanation: This invariant iterates over all possible pairs of Personne instances (p1 and p2)[cite: 37]. It states that for all pairs, if p1 and p2 are different objects, then their num attributes must also be different[cite: 37].\n\n\nKey Concepts Illustrated:\n\nContext: The context Personne declaration specifies that the constraint applies to the Personne class[cite: 31].\nInvariant (inv): An invariant is a rule that must always be true for all instances of a class throughout their lifetime[cite: 25].\nallInstances(): A class-level operation that returns a collection of all instances of that class in the system[cite: 31, 36].\nCollection Operations: This exercise showcases two fundamental collection operations: isUnique() for a direct check [cite: 31] and forAll() for expressing complex logical conditions on all elements[cite: 36].\n\n\n\n\n\n\n7.0.2 Exercise 2: Uniqueness Within a Group\nProblem: For the company organization model, an employee’s ID number (matricule) must be unique within their department, but not necessarily across the entire company[cite: 59]. Write an OCL constraint to enforce this rule.\n\n\n\n\n\n\nClick to see the solution\n\n\n\n\n\n\n\n\nUML diagram for the Company Organization exercise.\n\n\nCorrection Details:\nThe key to this problem is choosing the correct context. The constraint is about the uniqueness of employees within a department, so the most logical context is Departement[cite: 72].\n\nCorrect Solution: Context Departement [cite: 68] This approach is simple and directly models the requirement[cite: 70]. It evaluates the constraint for each department individually[cite: 72]. An idiomatic way to write this is using isUnique():\ncontext Departement inv pKeyEmploye:\n  self.employe-&gt;isUnique(matricule)\nThe provided source also shows an equivalent formulation using forAll[cite: 70]: ocl   context Departement inv pKeyEmploye:     self.employe-&gt;forAll(e1, e2 | e1 &lt;&gt; e2 implies e1.matricule &lt;&gt; e2.matricule)\n\nExplanation: For each instance of Departement (self), we navigate the employe association to get the collection of employees in that department. We then ensure that all matricule attributes within that collection are unique[cite: 71].\n\n\nKey Concepts Illustrated:\n\nChoosing the Right Context: This is the most important lesson. Placing the invariant in the Departement context radically simplifies the expression and makes the intent clear[cite: 72].\nNavigation: The expression self.employe demonstrates navigation across an association from an instance of one class to a collection of related instances[cite: 70].\nScoped Uniqueness: This exercise contrasts with the first one by showing how to enforce uniqueness within a specific scope (a department) rather than globally.\n\n\n\n\n\n\n7.0.3 Exercise 3: Preventing Circular Composition\nProblem: In the geometric figures model, a composite figure (FigureComposee) is made up of other figures. It is crucial to prevent circular compositions, where a figure could contain itself, either directly or indirectly[cite: 91]. Write an OCL constraint to forbid this.\n\n\n\n\n\n\nClick to see the solution\n\n\n\n\n\n\n\n\nUML diagram for the Geometric Figures exercise.\n\n\nCorrection Details:\nThis problem requires two levels of solution: one for direct cycles and a more advanced one for indirect cycles.\n\nSolution 1: Preventing Direct Cycles This constraint prevents a FigureComposee from including itself in its immediate list of sub-figures[cite: 98, 101].\ncontext FigureComposee inv circularComposition:\n  not self.figure-&gt;includes(self)\n\nExplanation: For any instance of FigureComposee (self), this invariant checks the collection of its direct sub-figures (self.figure) and asserts that the collection does not include the instance itself[cite: 99].\n\nSolution 2: Preventing Indirect Cycles (Advanced) The first solution is insufficient because it doesn’t prevent A from containing B, which in turn contains A[cite: 102]. To solve this, we need a recursive query to find all sub-figures at any level of nesting (the transitive closure)[cite: 103, 114].\ncontext FigureComposee\n-- Define a helper function to get all nested sub-figures\ndef: allSubFigures(): Set(Figure) = \n  self.figure-&gt;union(\n    self.figure-&gt;select(f | f.oclIsTypeOf(FigureComposee))\n                -&gt;collect(f | f.allSubFigures())\n                -&gt;flatten()\n  )\n\n-- The invariant uses the helper function\ninv noCircularComposition:\n  not self.allSubFigures()-&gt;includes(self)\n\nExplanation: We first define a helper operation allSubFigures() that recursively collects all direct figures and all sub-figures of any composite children[cite: 114]. The invariant noCircularComposition then uses this function to check that self is not present in the complete set of its descendants, thus preventing all direct and indirect cycles[cite: 113, 114].\n\n\nKey Concepts Illustrated:\n\nincludes(): A collection operation that checks for the presence of an element.\nHelper Operations (def): OCL allows the definition of custom, reusable queries, which is essential for complex logic like recursion[cite: 103].\nRecursion and Transitive Closure: The allSubFigures() operation is a classic example of using recursion to navigate a hierarchical structure to find all connected nodes[cite: 114].\n\n\n\n\n\n\n7.0.4 Exercise 4: Constraining Family Relationships\nProblem: Using the family links diagram, impose a constraint to forbid a person from being both a parent and a spouse to the same other person[cite: 125].\n\n\n\n\n\n\nClick to see the solution\n\n\n\n\n\n\n\n\nUML diagram for the Family Links exercise.\n\n\nCorrection Details:\nThe constraint needs to ensure that the set of a person’s children and the set of a person’s spouses are disjoint (have no common elements)[cite: 126].\ncontext Personne inv notChildParentsMarriage:\n  self.conjoint-&gt;excludesAll(self.enfant)\nExplanation:\n\nself: Refers to the instance of the Personne class on which the constraint is being evaluated.\nconjoint: Refers to the association that links a person to their spouse(s). It returns a collection of Personne objects.\nenfant: Refers to the association that links a person to their children.\nexcludesAll(): This OCL collection operation returns true if the first collection (the spouses) contains none of the elements from the second collection (the children).\n\nKey Concepts Illustrated:\n\nReflexive Association: The diagram shows the Personne class related to itself. OCL navigates these associations using the provided role names (conjoint, enfant).\nSet Operations: OCL provides a rich set of operations for working with collections, including excludesAll(), which is used here to ensure two sets are disjoint.\n\n\n\n\n\n\n7.0.5 Exercise 5: Hotel\nProblem: A hotel is composed of at least two “rooms”. Each room consists of several parts such as bedrooms, washrooms, living rooms, and meeting rooms. Each room has a minimum of one bedroom and one washroom. The washrooms can be bathrooms (with a tub) or shower rooms. A room is also characterized by a price and a number. The hotel itself has a category, and an address. Furthermore, the hotel can host clients, employ staff, and is managed by a staff member.\n\n\n\n\n\n\nClick to see the solution\n\n\n\n\n\n\n\n\nUML diagram for the Hotel exercise.\n\n\nCorrection Details:\nThe problem requires two OCL invariants to ensure the correct composition of a hotel room (Chambre).\n\nConstraint 1: Each room must have at least one bedroom. This constraint can be formulated in two ways. The first filters the collection of parts and checks its size, while the second (and more efficient) way simply checks for the existence of such a part.\nFormulation A: Using select and size\ncontext Chambre inv minChambreACoucher:\n  self.piece-&gt;select(p | p.oclIsTypeOf(ChambreACoucher))-&gt;size() &gt;= 1\nFormulation B: Using exists\ncontext Chambre inv minChambreACoucher:\n  self.piece-&gt;exists(p | p.oclIsTypeOf(ChambreACoucher))\nConstraint 2: Each room must have at least one washroom. Similarly, this constraint verifies that at least one of the room’s parts is a SalleDEau (which is a superclass for SalleDeBain and SalleDeDouche).\nFormulation A: Using select and size\ncontext Chambre inv minSalleDEau:\n  self.piece-&gt;select(p | p.oclIsTypeOf(SalleDEau))-&gt;size() &gt;= 1\nFormulation B: Using exists\ncontext Chambre inv minSalleDEau:\n  self.piece-&gt;exists(p | p.oclIsTypeOf(SalleDEau))\n\nKey Concepts Illustrated:\n\nNavigation: The constraints start from an instance of Chambre (self) and navigate the piece association to access the collection of parts.\noclIsTypeOf(): This operation is used to filter a collection of objects based on their specific class.\nselect() vs. exists(): This exercise highlights two common ways to check for the presence of an item in a collection. select() creates a new sub-collection, while exists() returns a simple boolean, which is often clearer and more performant for this type of rule.\n\n\n\n\n\n\n7.0.6 Exercise 6: Banking System\nProblem: Model a banking system where people own accounts in banking organizations. Enforce several business rules using OCL, including data integrity invariants (unique IDs, balance limits), initial attribute values, pre- and post-conditions for account operations (deposit, withdrawal), and queries to retrieve client information.\n\n\n\n\n\n\nClick to see the solution\n\n\n\n\n\n\n\n\nUML diagram for the Banking System exercise.\n\n\nCorrection Details:\nThis comprehensive exercise uses multiple OCL features to define the behaviour and constraints of a banking system.\n1. Invariants (Data Integrity Rules)\nThese rules must always be true for the system to be in a valid state.\n\nUnique account number per bank:\ncontext OrganismeBancaire inv pKeyCompte:\n  self.compte-&gt;isUnique(numero)\nExplanation: For each bank, the set of its accounts must have unique numbers.\nThe balance of an account cannot exceed 1,000,000:\ncontext Compte inv creditMax:\n  self.solde &lt;= 1000000\nThe interest rate must be strictly positive:\ncontext Compte inv tauxPositif:\n  self.taux &gt; 0\nA person’s ID must be unique:\ncontext Personne inv idUnique:\n  Personne.allInstances()-&gt;isUnique(numero)\n\n2. Initial and Derived Values\nOCL can specify initial values for attributes or define attributes whose values are derived from others.\n\nThe balance of a new account is initialized to 0:\ncontext Compte::solde: Real\n    init: 0\nThe interest amount is derived from the balance and rate:\ncontext Compte::interets: Real\n    derive: solde * taux\n\n3. Pre- and Post-conditions (Operation Contracts)\nThese define the “contract” for an operation: what must be true before it runs (pre) and what must be true after it finishes (post).\n\nDeposit money (verser):\ncontext Compte::verser(montant: Real)\n    pre montantPositif: montant &gt; 0\n    post soldeMisAJour: self.solde = self.solde@pre + montant\nExplanation: The precondition requires the deposit amount to be positive. The postcondition guarantees the new balance is the old balance (@pre) plus the amount.\nWithdraw money (retirer):\ncontext Compte::retirer(montant: Real)\n    pre montantPositif: montant &gt; 0\n    pre soldeSuffisant: self.solde &gt;= montant\n    post soldeMisAJour: self.solde = self.solde@pre - montant\nExplanation: The preconditions require a positive amount and sufficient funds. The postcondition guarantees the balance is correctly updated.\nGet balance (obtenirSolde):\ncontext Compte::obtenirSolde(): Real\n    post resultatCorrect: result = self.solde\n    post soldeInchange: self.solde = self.solde@pre\nExplanation: The postconditions guarantee the returned value (result) is the current balance and that the operation did not change the state of the balance.\n\n4. Queries (Helper Definitions)\nOCL can be used to define reusable queries on the model.\n\nGet a list of all distinct client first names:\ncontext Personne def: listePrenomsDifferents(): Set(String) =\n  Personne.allInstances()-&gt;collect(prenom)-&gt;asSet()\nExplanation: This defines a function that gets all Personne instances, collects their first names (prenom), and converts the resulting collection into a Set to ensure uniqueness.\n\nKey Concepts Illustrated:\n\nInvariants (inv): Rules that define a stable and consistent state for the model’s objects.\nInitializers (init): Specifies the state of an attribute upon an object’s creation.\nDerived Values (derive): Defines an attribute whose value is automatically calculated from other properties.\nDesign by Contract (pre, post): A powerful method for specifying the precise behaviour of operations.\n@pre: A keyword used in post-conditions to refer to the value of a property before the operation was executed.\nresult: A keyword used in post-conditions to refer to the value returned by the operation.\nQuerying (def): Using OCL not just for constraints, but to define reusable functions that can be called to retrieve information from the model.",
    "crumbs": [
      "<span class='chapter-number'>7</span>  <span class='chapter-title'>Practical Exercises: OCL Constraints</span>"
    ]
  },
  {
    "objectID": "08-state-machine-diagrams.html",
    "href": "08-state-machine-diagrams.html",
    "title": "8  State Machine Diagrams",
    "section": "",
    "text": "8.1 Why We Need State Machines\nThis chapter delves into one of UML’s core behavioural modelling tools: the State Machine Diagram. While Class Diagrams describe a system’s static structure, State Machine Diagrams model its dynamic behaviour. They focus on the lifecycle of a single object, detailing the sequence of states it passes through in response to events.\nClass Diagrams are excellent for defining what an object is and what it can do (its attributes and operations), but they often fall short in specifying when those operations can be called. This temporal ordering, or protocol, is crucial for modelling an object’s lifecycle.\nConsider a simple Door object. Its usage is governed by rules:\nWhile these rules can be described using OCL preconditions, this approach provides a fragmented view and doesn’t clearly show how the operations are linked together. State Machine Diagrams excel at visualizing this entire lifecycle in a single, coherent view.",
    "crumbs": [
      "<span class='chapter-number'>8</span>  <span class='chapter-title'>State Machine Diagrams</span>"
    ]
  },
  {
    "objectID": "08-state-machine-diagrams.html#core-concepts-of-state-machines",
    "href": "08-state-machine-diagrams.html#core-concepts-of-state-machines",
    "title": "8  State Machine Diagrams",
    "section": "8.2 Core Concepts of State Machines",
    "text": "8.2 Core Concepts of State Machines\nA State Machine Diagram visualizes an object’s behaviour as a journey through a finite number of states. It discretizes behaviour into a set of relevant, abstract states, ignoring irrelevant details. For a Door, the relevant states might be Open, Closed, and Locked; its color is an irrelevant detail.\n\n\n\nA simple protocol state machine diagram for a Door class.\n\n\nThe diagram is composed of a few key elements:\n\nState: A condition during the life of an object in which it satisfies some condition, performs some activity, or waits for an event. It’s shown as a rectangle with rounded corners.\nTransition: A directed relationship between a source state and a target state. It specifies that an object in the source state will enter the target state when a specific event occurs and certain conditions are met. Transitions are considered instantaneous.\nInitial State: A pseudostate indicating the default starting point. It is shown as a solid black circle.\nFinal State: A state indicating that the object has completed its lifecycle. It is shown as a circle surrounding a smaller solid circle (a bullseye).\n\n\n8.2.1 Anatomy of a Transition\nA transition moves an object from one state to another. Its full syntax is trigger-event [guard] / effect. Each part defines a specific aspect of the state change.\n\n\n\nA visual representation of a UML transition, labeling the trigger, guard, and effect components.\n\n\n\nTrigger (or Event): The event that causes the transition to be considered. There are four main types of events:\n\nCall Event: The most common type. It corresponds to the reception of a synchronous call to an operation of the object. The syntax is simply the operation’s name, for example, open() or deposit(amount).\nSignal Event: Corresponds to the reception of an asynchronous signal by an object. Unlike an operation call, the sender does not wait for a reply. The syntax is the signal’s name, for example, onAlarmDetection.\nChange Event: This event occurs when a specific boolean expression becomes true. It is used to model reactions to changing conditions. The syntax uses the when keyword, for example, when(sensor.isConnected).\nTime Event: Occurs after a certain amount of time has passed or at a specific time. The syntax uses the after keyword (for a relative duration) or the at keyword (for an absolute time). For example, after(5 seconds) or at(2025-12-25).\n\nGuard: An optional boolean condition that must be true for the transition to fire. It is written in square brackets, e.g., [doorway.empty].\nEffect (or Action): An optional behaviour that is executed at the instant the transition fires.",
    "crumbs": [
      "<span class='chapter-number'>8</span>  <span class='chapter-title'>State Machine Diagrams</span>"
    ]
  },
  {
    "objectID": "08-state-machine-diagrams.html#protocol-vs.-behavioral-state-machines",
    "href": "08-state-machine-diagrams.html#protocol-vs.-behavioral-state-machines",
    "title": "8  State Machine Diagrams",
    "section": "8.3 Protocol vs. Behavioral State Machines",
    "text": "8.3 Protocol vs. Behavioral State Machines\nUML distinguishes between two main types of state machines, which serve different purposes.\n\n8.3.1 Protocol State Machines\nA Protocol State Machine specifies the legal sequence of operations that can be called on an object. It acts as a “user manual” for a class, defining its lifecycle without specifying the implementation of its behavior. Transitions in a protocol state machine have triggers and guards, but no effects.\n\n\n\n\n\n\nKey Idea: Protocol State Machine\n\n\n\nA Protocol State Machine defines the valid order of operations. It answers the question: “What can happen next?” It is primarily used during analysis and interface specification.\n\n\nA key question for protocol state machines is what happens when an unexpected event occurs (e.g., a slam() event arrives at a Door). UML leaves this undefined, meaning it’s up to the modeler to specify whether such events are ignored, rejected, or cause an error.\n\n\n8.3.2 Behavioral State Machines\nA Behavioral State Machine goes further by specifying the object’s reactions to events. It models the effects (actions or activities) that are executed when transitions occur or when the object is in a particular state.\n\n\n\n\n\n\nKey Idea: Behavioral State Machine\n\n\n\nA Behavioral State Machine defines what an object does in response to events. It is a specification of implementation and is used during system design and construction.\n\n\nIn addition to effects on transitions, states themselves can have associated behaviors:\n\nEntry Action: Executed whenever the state is entered (entry / action).\nExit Action: Executed whenever the state is exited (exit / action).\nDo Activity: An ongoing activity performed as long as the object remains in that state (do / activity). It can be interrupted by an outgoing transition.\n\n\n\n\nA behavioral state machine showing entry and exit actions.\n\n\nIn contrast to protocol state machines, behavioral state machines have a default behavior for unexpected events: they are simply ignored.",
    "crumbs": [
      "<span class='chapter-number'>8</span>  <span class='chapter-title'>State Machine Diagrams</span>"
    ]
  },
  {
    "objectID": "08-state-machine-diagrams.html#advanced-concepts-structuring-complexity",
    "href": "08-state-machine-diagrams.html#advanced-concepts-structuring-complexity",
    "title": "8  State Machine Diagrams",
    "section": "8.4 Advanced Concepts: Structuring Complexity",
    "text": "8.4 Advanced Concepts: Structuring Complexity\nReal-world objects can have complex behaviours that would lead to messy, unreadable “flat” state machines. UML provides powerful structuring mechanisms to manage this complexity.\n\n8.4.1 Hierarchical States (Composite States)\nA Composite State is a state that contains its own nested state machine. This allows for abstraction and top-down reasoning. A high-level state like Working can be expanded to reveal a detailed sub-machine that handles its internal logic. This is powerful because a single transition leaving the composite state (e.g., shutdown()) applies to all of its substates, dramatically reducing visual clutter.\n\n\n\nA composite state ‘Working’ containing a full sub-machine.\n\n\n\n\n8.4.2 Orthogonal Regions (Concurrency)\nAn Orthogonal State is a composite state that is divided into two or more independent regions, each with its own sub-machine. When an object is in an orthogonal state, it is simultaneously in one substate from each region. This is UML’s way of modelling independent, concurrent behaviours within a single object, which avoids a “combinatorial explosion” of states.\nThe primary mechanism for entering and exiting these concurrent regions is through Fork and Join pseudostates. A fork splits a single incoming transition into multiple concurrent transitions, one for each region. A join synchronizes multiple incoming transitions from different regions into a single outgoing transition.\n\n\n\nA Fork pseudostate splits one transition into three concurrent paths, which are later synchronized by a Join pseudostate.\n\n\n\n\n8.4.3 Other Essential Pseudostates\nTo create sophisticated flows, UML provides several other special states (pseudostates):\n\nChoice vs. Junction: These both represent branches in a transition path, but their semantics are critically different. The key distinction is when the guards are evaluated relative to the transition’s actions.\n\nA Choice (diamond) models a dynamic branch. Its guards are evaluated after the actions on the incoming transition segment have been executed.\nA Junction (circle) models a static branch. Its guards are evaluated before any actions are executed.\n\n\n\n\n\nWith a Junction, the path is chosen based on x’s initial value. With a Choice, the path is chosen after x has been set to 0.\n\n\n\nHistory States: A History State (H or H*) is a pseudostate that remembers the last active substate of a composite state. This is invaluable for modelling interruptions.\n\nShallow History (H): Remembers only the immediate substate. If Connected is left while in the Running state, a transition to H will resume in Running.\nDeep History (H*): Remembers the full state configuration. If the machine was in the Fast sub-state of Running, a transition to H* would resume in Fast.\n\n\n\n\n\nA Shallow History (H) connector inside a ‘Connected’ composite state.\n\n\n\n\n\nA Deep History (H*) connector inside a composite state that has its own nested states.\n\n\n\nEntry and Exit Points: These provide fine-grained control for transitions that cross the boundary of a composite state, allowing them to bypass the default initial/final states.\n\nAn Entry Point allows a transition to target a specific internal state, useful for skipping initialization steps.\nAn Exit Point allows an internal state to trigger a specific transition out of the composite state, useful for handling specific outcomes like errors.\n\n\n\n\n\nAn Entry Point allows a higher-level state to transition to a specific substate, bypassing the default initial state.\n\n\nBy using these advanced features, State Machine Diagrams can model even the most complex object lifecycles in a structured, understandable, and precise way.",
    "crumbs": [
      "<span class='chapter-number'>8</span>  <span class='chapter-title'>State Machine Diagrams</span>"
    ]
  },
  {
    "objectID": "08-state-machine-diagrams.html#why-we-need-state-machines",
    "href": "08-state-machine-diagrams.html#why-we-need-state-machines",
    "title": "8  State Machine Diagrams",
    "section": "",
    "text": "A door can only be opened if it is currently closed and unlocked.\nA door can only be closed if it is open and the doorway is clear.\nTurning the key locks an unlocked door and unlocks a locked one.",
    "crumbs": [
      "<span class='chapter-number'>8</span>  <span class='chapter-title'>State Machine Diagrams</span>"
    ]
  },
  {
    "objectID": "08-state-machine-diagrams.html#state-machine-semantics-the-rules-of-execution",
    "href": "08-state-machine-diagrams.html#state-machine-semantics-the-rules-of-execution",
    "title": "8  State Machine Diagrams",
    "section": "8.5 State Machine Semantics: The Rules of Execution",
    "text": "8.5 State Machine Semantics: The Rules of Execution\nWhile State Machine diagrams are visually intuitive, their execution follows a precise set of rules, or semantics. Understanding these rules is essential for correctly interpreting complex diagrams and predicting system behaviour, especially when ambiguities like conflicts or concurrency arise.\n\n8.5.1 Configurations and Conflicts\nAt any moment, a system’s state is defined by its configuration: the set of all currently active states at every level of the hierarchy.\nA conflict occurs when a single event could trigger multiple different transitions from the current configuration. For two transitions to be in conflict, they must:\n\nBe triggered by the same event.\nHave guards that are both true.\nOriginate from source states that overlap (e.g., a state and its substate).\n\n\n\n8.5.2 The UML Priority Rule\nTo resolve conflicts, UML defines a clear priority rule: the transition originating from the most deeply nested state has priority. This means an action defined on a substate will always be chosen over a conflicting action defined on one of its parent states. It’s important to note this is a specific convention of UML, other formalisms might use different rules.\n\n\n\nA complex hierarchical state machine where the “deepest source state” rule is needed to resolve which transition fires when event ‘a’ occurs.\n\n\n\n\n8.5.3 Non-Determinism: When the Rules Aren’t Enough\nSometimes, the priority rule is not sufficient to resolve all ambiguities. This leads to non-determinism, where the model allows for more than one possible correct behaviour.\n\nUnresolvable Conflicts: In an orthogonal state, if an event triggers a transition in one region and a conflicting transition in another, the priority rule does not apply because neither state is “deeper” than the other. The system will make a non-deterministic choice and fire only one of the enabled transitions.\n\n\n\n\nIn this diagram, if event ‘a’ occurs, both transitions fire. The final value of ‘x’ is non-deterministic because the firing order is undefined.\n\n\n\nSimultaneous Transitions & Undefined Order: If an event triggers one transition in each of several orthogonal regions, all transitions will fire. However, the order in which their actions are executed is undefined. If these actions modify a shared variable, the final value of that variable can be unpredictable, as it depends on which action runs last. More generally, if the actions are sequences like a;b;c and e;f;g, any interleaving of these sequences is considered a valid execution.\n\n\n\n\nIn this diagram, if event ‘a’ occurs, both transitions fire. The final value of ‘x’ is non-deterministic because the firing order is undefined.\n\n\n\n\n8.5.4 Semantics of Junctions and Choices\nThe distinction between Junction and Choice pseudostates is purely semantic and relates to when guards are evaluated within a single, run-to-completion step:\n\nJunction (Static): A junction is evaluated “beforehand.” The entire path from the source state to the final target state is determined before any actions on the transitions are executed.\nChoice (Dynamic): A choice is evaluated “after.” The system executes the action on the incoming transition segment first, and only then evaluates the guards on the outgoing paths to determine where to go next.\n\n\n\n\nWith a Junction (left), the path is chosen based on x’s initial value. With a Choice (right), the path is chosen after x has been set to 0.",
    "crumbs": [
      "<span class='chapter-number'>8</span>  <span class='chapter-title'>State Machine Diagrams</span>"
    ]
  },
  {
    "objectID": "08-state-machine-diagrams.html#protocol-vs.-behavioural-state-machines",
    "href": "08-state-machine-diagrams.html#protocol-vs.-behavioural-state-machines",
    "title": "8  State Machine Diagrams",
    "section": "8.3 Protocol vs. behavioural State Machines",
    "text": "8.3 Protocol vs. behavioural State Machines\nUML distinguishes between two main types of state machines, which serve different purposes.\n\n8.3.1 Protocol State Machines\nA Protocol State Machine specifies the legal sequence of operations that can be called on an object. It acts as a “user manual” for a class, defining its lifecycle without specifying the implementation of its behaviour. Transitions in a protocol state machine have triggers and guards, but no effects.\n\n\n\n\n\n\nKey Idea: Protocol State Machine\n\n\n\nA Protocol State Machine defines the valid order of operations. It answers the question: “What can happen next?” It is primarily used during analysis and interface specification.\n\n\nA key question for protocol state machines is what happens when an unexpected event occurs (e.g., a slam() event arrives at a Door). UML leaves this undefined, meaning it’s up to the modeller to specify whether such events are ignored, rejected, or cause an error.\n\n\n8.3.2 behavioural State Machines\nA behavioural State Machine goes further by specifying the object’s reactions to events. It models the effects (actions or activities) that are executed when transitions occur or when the object is in a particular state.\n\n\n\n\n\n\nKey Idea: behavioural State Machine\n\n\n\nA behavioural State Machine defines what an object does in response to events. It is a specification of implementation and is used during system design and construction.\n\n\nIn addition to effects on transitions, states themselves can have associated behaviours:\n\nEntry Action: Executed whenever the state is entered (entry / action).\nExit Action: Executed whenever the state is exited (exit / action).\nDo Activity: An ongoing activity performed as long as the object remains in that state (do / activity). It can be interrupted by an outgoing transition.\n\n\n\n\nA behavioural state machine showing entry and exit actions.\n\n\nIn contrast to protocol state machines, behavioural state machines have a default behaviour for unexpected events: they are simply ignored.",
    "crumbs": [
      "<span class='chapter-number'>8</span>  <span class='chapter-title'>State Machine Diagrams</span>"
    ]
  },
  {
    "objectID": "09-practical-exercises-state-machine-diagrams.html",
    "href": "09-practical-exercises-state-machine-diagrams.html",
    "title": "9  Practical Exercises: State Machines",
    "section": "",
    "text": "This chapter provides a series of practical exercises to apply the concepts of UML State Machines discussed previously. Each exercise challenges you to trace the execution of a complex state machine by applying semantic rules to determine the stable configuration after each event.\n\n\n9.0.1 Exercise 1: Orthogonal Regions and History\nProblem: Consider the state machine diagram below. Starting from the initial configuration {A}, trace the system’s configuration through the given sequence of events.\n\n\n\n\n\n\nClick to see the solution\n\n\n\n\n\n\n\n\nState Machine for Exercise 1.\n\n\nCorrection Details:\n\n\n\n\n\n\n\n\n\n\nStep\nInitial Config.\nEvent\nFinal Config.\nJustification\n\n\n\n\n1\n{A}\ny\n{B,C,E}\nA -&gt; B is the only possible transition; C and E are entered via the fork.\n\n\n2\n{B,C,E}\nu\n{B,D,F}\nThe C -&gt; D transition fires. Its reaction sends a q event, which is consumed. The system enters D. Because the in(D) guard is now true, a transition to F is taken. The final stable state is {B,D,F}.\n\n\n3\n{B,D,F}\nq\n{B,D,F}\nThe system leaves F for E. Since it is still in state D, the in(D) guard is true, causing an immediate transition back to F for a stable state of {B,D,F}.\n\n\n4\n{B,D,F}\nt\n{B,C,F}\nThe system remains in B. The D -&gt; C transition occurs. The system remains in F.\n\n\n5\n{B,C,F}\nq\n{B,C,E}\nThe system remains in B. The F -&gt; E transition occurs. The system remains in C.\n\n\n6\n{B,C,E}\ns\n{B,C,E}\nThe system leaves B and re-enters it. C is restored because of the History state (H). E is activated because it’s the initial state of its region.\n\n\n7\n{B,C,E}\nu\n{B,D,F}\nSame as step 2.\n\n\n8\n{B,D,F}\ns\n{B,D,F}\nThe system leaves B and re-enters it. D is restored due to History. E is activated as the initial state, but an immediate transition to F occurs because the in(D) guard is true.\n\n\n9\n{B,D,F}\nt\n{B,C,F}\nThe system remains in B. The D -&gt; C transition occurs. The system remains in F.\n\n\n10\n{B,C,F}\nv\n{G}\nThe system leaves B for G. This is enabled by the exit point, as the active state C is connected to it.\n\n\n\nKey Concepts Illustrated:\n\nOrthogonal Regions: Modeling concurrent states that are active simultaneously.\nRun-to-Completion Semantics: How an event and its subsequent internal reactions are processed to completion before the next external event is handled.\nShallow History (H): The mechanism for remembering and restoring the last active substate within a region.\nForks and Exit Points: The syntax and semantics for managing the start and end of concurrent flows.\n\n\n\n\n\n\n\n9.0.2 Exercise 2: Submachines and Deep History\nProblem: Consider the state machine Z, which uses the submachine C. Starting from the initial configuration {Z, A, B}, trace the system’s configuration for the given event sequence.\n\n\n\n\n\n\nClick to see the solution\n\n\n\n\n\n\n\n\nState Machine and Submachine for Exercise 2.\n\n\nCorrection Details:\n\n\n\n\n\n\n\n\n\n\nStep\nInitial Config.\nEvent\nFinal Config.\nJustification\n\n\n\n\n1\n{Z, A, B}\ns\n{Z, A, C, D}\nA remains active; the B -&gt; C transition occurs; D is the initial state of the submachine C.\n\n\n2\n{Z, A, C, D}\nu\n{Z, A, C, E}\nThe D -&gt; E transition occurs. E is an exit state that enables the A -&gt; G transition.\n\n\n3\n{Z, A, C, E}\nr\n{Z, A, C, E}\nNothing happens.\n\n\n4\n{Z, A, C, E}\nu\n{Z, G, I, J, M}\nThe A -&gt; G transition fires via the active exit point. I and J are activated as initial states in the top region, and M is the initial state of the bottom orthogonal region.\n\n\n5\n{Z, G, I, J, M}\nx\n{Z, G, L, N}\nThe I -&gt; L transition fires, launching and consuming event w. The in(L) guard is now true, so the M -&gt; N transition also fires.\n\n\n6\n{Z, G, L, N}\nv\n{Z, G, I, J, N}\nZ and G remain active. The L -&gt; I transition fires. J is restored because of the deep history state (H*).\n\n\n7\n{Z, G, I, J, N}\nz\n{Z, G, I, J, N}\nNothing happens.\n\n\n8\n{Z, G, I, J, N}\ny\n{Z, G, I, K, N}\nThe J -&gt; K transition occurs.\n\n\n9\n{Z, G, I, K, N}\nt\n{Z, A, C, D}\nThe system leaves G for A. C is restored due to shallow history (H). D is activated as the initial state of C because the history of A is not deep.\n\n\n10\n{Z, A, C, D}\nu\n{Z, A, C, E}\nSame as step 2.\n\n\n11\n{Z, A, C, E}\nu\n{Z, G, I, K, N}\nThe system leaves A for G via the exit point. In the top region, {I, K} is restored due to deep history. In the bottom region, N is restored due to its shallow history.\n\n\n12\n{Z, G, I, K, N}\nx\n{Z, G, L, N}\nThe I -&gt; L transition fires, launching event w. This w event causes N -&gt; M. The system enters L, making the in(L) guard true, which causes an immediate M -&gt; N transition. The final stable state is {Z, G, L, N}.\n\n\n\nKey Concepts Illustrated:\n\nSubmachine States: How a state can be a reference to another, reusable state machine definition, promoting encapsulation.\nDeep History (H*) vs. Shallow History (H): This exercise provides a perfect side-by-side comparison. Shallow history restores the immediate substate, while deep history restores the entire nested configuration.\nInteraction between Model Components: Tracing how transitions and history mechanisms work across the boundaries of composite states and submachines.\n\n\n\n\n\n\n\n9.0.3 Exercise 3: Advanced Semantics and Priority Rules\nProblem: For the highly complex state machine below, trace the configuration starting from {A, B, F, H}. This exercise will test your understanding of conflict resolution.\n\n\n\n\n\n\nClick to see the solution\n\n\n\n\n\n\n\n\nState Machine for Exercise 3.\n\n\nCorrection Details:\n\n\n\n\n\n\n\n\n\n\nNo.\nInitial Config.\nEvent\nFinal Config.\nJustification\n\n\n\n\n1\n{A, B, F, H}\nm1\n{A, B, F, H}\nThe system leaves A and re-enters it. B is the initial state, F is restored due to History, and H is the initial state.\n\n\n2\n{A, B, F, H}\nm2/m3\n{A, B, G, H}\nm2 is the event, m3 is the reaction. The F -&gt; G transition fires, launching m3. A conflict arises between the high-level B -&gt; C transition and the nested H -&gt; H self-transition. The H -&gt; H transition has priority because it is more deeply nested. m3 is consumed, and the final stable state is {A, B, G, H}.\n\n\n3\n{A, B, G, H}\nm4\n{A, D}\nThe B -&gt; D transition occurs.\n\n\n4\n{A, D}\nm4\n{A, B, G, H}\nThe D -&gt; B transition occurs. G is restored due to history, and H is activated as the initial state.\n\n\n5\n{A, B, G, H}\nm3\n{A, B, G, H}\nThe system leaves H and re-enters it; the H -&gt; H transition is the most deeply nested and thus has priority.\n\n\n6\n{A, B, G, H}\nm1\n{A, B, F, H}\nThe G -&gt; F transition is the most deeply nested.\n\n\n7\n{A, B, F, H}\nm1\n{A, B, F, H}\nThe system leaves A and re-enters it. B is the initial state, F is restored due to History, and H is the initial state.\n\n\n8\n{A, B, F, H}\nm8\n{A, B, F, H}\nNothing happens.\n\n\n9\n{A, B, F, H}\nm3/m8\n{A, B, F, H}\nThe system leaves H and re-enters it. The H -&gt; H transition is the most deeply nested (the reaction m8 is not considered here).\n\n\n10\n{A, B, F, H}\nm1\n{A, B, F, H}\nSame as step 7.\n\n\n\nKey Concepts Illustrated:\n\nThe UML Priority Rule: This exercise provides a clear, practical example of conflict resolution. The rule—“deepest source state wins”—is not just theoretical; it dictates the machine’s behavior.\nReactions and Internal Events: Demonstrates how a transition’s action can trigger a new event that is immediately processed within the same “run-to-completion” step.\nComplex Transitions: Shows how to trace execution across multiple levels of hierarchy and through exit points that depend on the configuration of multiple orthogonal regions.",
    "crumbs": [
      "<span class='chapter-number'>9</span>  <span class='chapter-title'>Practical Exercises: State Machines</span>"
    ]
  }
]